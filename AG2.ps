%% PsGeo2d.ps Macros postscript pour réaliser des figures planes
%% Copyright (C) 2010 Guy NOËL
%%This program is free software: you can redistribute it and/or modify
%% it under the terms of the GNU General Public License as published by
%% the Free Software Foundation, either version 3 of the License, or
%% any later version.
%% This program is distributed in the hope that it will be useful,
%% but WITHOUT ANY WARRANTY; without even the implied warranty of
%% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
%% GNU General Public License for more details.
%% You should have received a copy of the GNU General Public License
%% along with this program. If not, see <http://www.gnu.org/licenses/>.
%%BeginProlog
%% Réencodage des alphabets
/reencdict 12 dict def
/ReEncode
  {reencdict begin
   /newcodesandnames exch def
   /newfontname exch def
   /basefontname exch def
   /basefontdict basefontname findfont def
   /newfont basefontdict maxlength dict def
   basefontdict
     {exch dup /FID ne
       {dup /Encoding eq
         {exch dup length array copy
          newfont 3 1 roll put }
         {exch newfont 3 1 roll put }
         ifelse
       }
       { pop pop }
       ifelse
     } forall
   newfont /FontName newfontname put
   newcodesandnames aload pop
   newcodesandnames length 2 idiv
     {newfont /Encoding get 3 1 roll put}
     repeat
   newfontname newfont definefont pop
   end
} def
% The following is a definition of the National Language characters and codes

/NLSVec [
 16#C0 /Agrave
 16#C1 /Aacute
 16#C2 /Acircumflex
 16#C3 /Atilde
 16#C4 /Adieresis
 16#C5 /Aring
 16#C6 /AE
 16#C7 /Ccedilla
 16#C8 /Egrave
 16#C9 /Eacute
 16#CA /Ecircumflex
 16#CB /Edieresis
 16#CC /Igrave
 16#CD /Iacute
 16#CE /Icircumflex
 16#CF /Idieresis
 16#D0 /Eth
 16#D1 /Ntilde
 16#D2 /Ograve
 16#D3 /Oacute
 16#D4 /Ocircumflex
 16#D5 /Otilde
 16#D6 /Odieresis
 16#D7 /multiply
 16#D8 /Oslash
 16#D9 /Ugrave
 16#DA /Uacute
 16#DB /Ucircumflex
 16#DC /Udieresis
 16#DD /Yacute
 16#DE /Thorn
 16#DF /germandbls
 16#E0 /agrave
 16#E1 /aacute
 16#E2 /acircumflex
 16#E3 /atilde
 16#E4 /adieresis
 16#E5 /aring
 16#E6 /ae
 16#E7 /ccedilla
 16#E8 /egrave
 16#E9 /eacute
 16#EA /ecircumflex
 16#EB /edieresis
 16#EC /igrave
 16#ED /iacute
 16#EE /icircumflex
 16#EF /idieresis
 16#F0 /eth
 16#F1 /ntilde
 16#F2 /ograve
 16#F3 /oacute
 16#F4 /ocircumflex
 16#F5 /otilde
 16#F6 /odieresis
 16#F7 /divide
 16#F8 /oslash
 16#F9 /ugrave
 16#FA /uacute
 16#FB /ucircumflex
 16#FC /udieresis
 16#FD /yacute
 16#FE /thorn
 16#FF /ydieresis
] def

%Exemples d'instructions de réencodage des alphabets 
%/Times-Italic /Times-Italic NLSVec ReEncode

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Macrosgn %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% macrosgn est un dictionnaire contenant les définitions qui suivent
/macrosgn 2048 dict def  %OK
macrosgn begin	      %OK
%(%stdout) (w) file /out exch store
/BBllx 10000 store /BBlly 10000 store /BBurx 0 store /BBury 0 store
/BBMessage {BB@ut exch writestring  flush} def 
/ajusterBB {eptr@ 2 div 1 add  /suplep exch store 
                     suplep add dup BBury gt {/BBury exch store}{pop} ifelse
                     suplep add dup BBurx gt {/BBurx exch store}{pop} ifelse 
                     suplep sub dup BBlly lt {/BBlly exch store}{pop} ifelse
                     suplep sub dup BBllx lt {/BBllx exch store}{pop} ifelse} def
/afficherBB { (BB.txt) (w) file /BB@ut exch store
                       (llx =) BBMessage  BBllx round str espacer  BBMessage  ( lly =)  BBMessage BBlly round str espacer BBMessage  
                       ( urx =) BBMessage BBurx round str  espacer BBMessage  ( ury =) BBMessage  BBury round str espacer BBMessage
                       BB@ut closefile} def
                         

%% Routines générales 
/nom? {dup type str (nametype) eq} def % xx -> xx true-ou-false
/entier? {dup type str (integertype) eq} def % xx -> xx true-ou-false
/reel? {dup type str (realtype) eq} def % xx -> xx true-ou-false
/nombre? {entier? {true}{reel?} ifelse} def % xx -> xx true-ou-false
/array? {dup type str (arraytype) eq} def % xx -> xx true-ou-false
/nonemptyarray? {array? {dup length 0 gt}{false} ifelse } def % xx -> xx true-ou-false
/point? {array? 
         {dup length 2 eq 
               {dup 0 get nombre? exch pop {dup 1 get nombre? exch pop}{false}ifelse}
               {false} ifelse}
        {false}ifelse} def % % xx -> xx true-ou-false
/secteur? {array? {dup length 4 eq {dup 0 get point? exch pop {dup 1 get point? exch pop {dup 2 get point? exch pop {dup 3 get nombre? exch pop}
                                                                                                                                                                                          {false} ifelse} 
                                                                                                                                               {false} ifelse} 
                                                                                                   {false} ifelse}
                                                       {false} ifelse}
                            {false} ifelse } def 
/suitepoints?{point? {true} {array? {dup true exch {point? exch pop and} forall} {false} ifelse} ifelse} def
                        %% % % xx -> xx true-ou-false
/bipoint? {suitepoints? {dup  length 2 eq} {false} ifelse} def
/droite? {bipoint?} def
/tripoint?{suitepoints? {dup length 3 eq } {false} ifelse} def
/arccercle?{tripoint?} def
/arcellipse?{array?{dup length 4 eq {dup 0 get tripoint? exch pop} {false} ifelse}{false} ifelse} def 
/cercle? {array? {dup length 2 eq
                 {dup 0 get point? exch pop {dup 1 get nombre? exch pop}{false}ifelse}
                 {false} ifelse}
        {false}ifelse} def % % xx -> xx true-ou-false
/chemin? {array? {dup  true exch {point? exch arccercle?  exch  arcellipse?  exch pop or or  and} forall } {false} ifelse} def

/accoupler {2 assembler} bind def
/decoupler {aload pop} bind def
/desassembler{aload pop} bind def
/assembler {array astore} bind def
/str {20 string cvs } bind def
/dans? {decoupler 2 copy gt {exch} if 2 index exch sub epszero ge 3 1 roll exch sub epszero ge or not} def  
        %% syntaxe r [a b] dans? (r, a et b réels) -> true ou false
%/multiple? {anglepolaire exch anglepolaire sub dup 0 eq exch 180 eq or} def 
        %% syntaxe p q multiple?
/alignes? {decoupler 3 assembler vectp abs epszero lt} def
/danssegment?{2 copy alignes? {2 copy decoupler abscisse exch abscisse accoupler exch abscisse exch dans?
                                                    3 1 roll  decoupler ordonnee exch ordonnee accoupler exch ordonnee exch dans? and}
                                                   {pop pop false} ifelse } def

%% Conversion des cm en points
/cm {28.35 mul} def %OK

%% Routines arithmétiques
/pgcd{2 copy gt {exch} if 1 index mod dup 0 eq {pop}{pgcd}ifelse} def 
   % calcule le pgcd de deux entiers syntaxe: a b pgcd -> d OK
/addt {/v2@ exch store /v1@ exch store 0 1 dim@nt 1 
          sub {dup v1@ exch get exch v2@ exch get add} for dim@nt array astore} def % OK

/tripascal{1 add /n@m1 exch store [[1] [1 1] n@m1 2 sub
   {dup length 1 add /dim@nt exch store dup dup [0] append exch [0] exch append addt } repeat ]
    /Pascal exch store} def
/coeffbin {exch Pascal exch get exch get} def % usage n k coeffbin --> (n k)
/max {2 copy lt {exch pop} {pop} ifelse} def
/min {2 copy lt {pop} {exch pop} ifelse} def

%% Fonctions trigonométriques
/cotg{dup cos exch sin div} def %OK
/tg {dup sin exch cos div} def %OK
/arccos {dup dup mul 1 exch sub sqrt exch atan} def %OK
/arcsin {dup dup mul 1 exch sub sqrt atan} def %OK
%% Conversion des radians en degrés %OK
/rad {180 mul 3.14159 div} def %OK
%% Valeur de pi
/pi 3.14159265 store
%% Valeur de e
/enep 2.718281828459045 store
/ch {dup enep exch exp exch enep exch neg exp add 2 div} def
/sh {dup enep exch exp exch enep exch neg exp sub 2 div} def
/th {dup sh exch ch div} def
/signe {dup abs dup 0 gt {div}{pop} ifelse} def
%%Cadre du dessin

/fixecadre {decoupler exch decoupler /y@t exch store /x@t exch store
            decoupler y@t sub /h@ exch store x@t sub /w@ exch store
            } def %OK

%% Fenêtre utilisateur 

/coord {w@ x@a x@i sub div /c@w exch store 
        h@ y@a y@i sub div /c@h exch store
        /M@t [c@w 0 0 c@h x@t c@w x@i mul sub y@t c@h y@i mul sub] store  
        @ngleref
}def %OK


/fixedomaine {decoupler decoupler /y@a exch store /x@a exch store 
                          decoupler /y@i exch store /x@i exch store coord} def %OK


%% Modification des instructions stroke, fill, moveto, lineto, etc
/fillstroke {gsave fill grestore stroke} def
/add2 {dup 4 1 roll add 3 1 roll add exch} def
/triplediag{dup decoupler 1 index eq {eq {1} {0} ifelse}{pop pop 0} ifelse} def %test de l'égalité des trois composantess
/fixcolor{dup length 3 eq {triplediag 1 eq {decoupler pop pop setgray}{decoupler setrgbcolor} ifelse}
                                        {decoupler setcmykcolor} ifelse} def
/stroke {c@ltrait fixcolor epaisseur  pathbbox ajusterBB end  stroke macrosgn begin} def 
/fill {c@lremp length 0 eq {end stroke macrosgn begin} {c@lremp fixcolor pathbbox ajusterBB end fill macrosgn begin} ifelse} def
/eofill {c@lremp length 0 eq {end stroke macrosgn begin} {c@lremp fixcolor end eofill macrosgn begin} ifelse} def
/show{c@lnom fixcolor dup  gsave false charpath pathbbox ajusterBB grestore end show macrosgn begin} def
/moveto{user {M@t transform} if end moveto macrosgn begin} def
/lineto{user {M@t transform} if end lineto macrosgn begin} def
/rmoveto{user {M@t dtransform} if end rmoveto macrosgn begin} def
/rlineto{user {M@t dtransform} if end rlineto macrosgn begin} def
/vr@f [1 0] store
/@ngleref {vr@f decoupler M@t dtransform exch atan /angleref exch store} def

/arc {user {/s@ns 1 store cercto@llip  @rcellip}{end arc macrosgn begin} ifelse} def
/arcn {user {/s@ns -1 store cercto@llip @rcellip}{end arcn macrosgn begin} ifelse} def
/arcto {user {/r@y exch store accoupler /p@2 exch store accoupler /p@1 exch store currentpoint accoupler /p@0 exch store
                    [p@0 p@1 p@2] vectp 0 gt {-1}{1} ifelse /s@ns exch store
                    p@2 [ p@0 p@1] perpd [ p@0 p@1] interdroites pop dup p@2 exch subp normer  r@y mulp addp [p@0 p@1] paralld
                    [p@0 p@1 p@2] bissecd interdroites pop /q@1 exch store
                    q@1 [p@0 p@1] perpd [p@0 p@1] interdroites pop /q@0 exch store
                    q@1 [p@1 p@2] perpd [p@1 p@2] interdroites pop /q@2 exch store
                    q@0 decoupler lineto q@1 decoupler r@y abs q@0 q@1 subp anglepolaire q@2 q@1 subp anglepolaire cercto@llip @rcellip 
                    q@0 decoupler q@2 decoupler}
                    {end arcto macrosgn begin} ifelse} def
/curveto {user { 3 {M@t transform 6 2 roll} repeat } if end curveto macrosgn begin} def
/updatem@t {M@t  matrix  concatmatrix /M@t exch store @ngleref} def
/tr@nsform {decoupler M@t transform accoupler} def
/translate {user {1 0 0 1 6 4 roll 6 array astore updatem@t} {end  translate macrosgn begin} ifelse} def
/rotate {user {dup cos exch sin 2 copy neg exch  0 0 6 array astore updatem@t} 
                    {end  rotate macrosgn begin} ifelse} def
/scale {user {0 0 3 2 roll 0 0 6 array astore updatem@t} {end scale macrosgn begin} ifelse} def
/concat {user {updatem@t}{end concat macrosgn begin} ifelse} def
/@mpiler {pilem@t [ M@t ] append /pilem@t exch store} def
/d@piler {pilem@t dup dup length 1 sub dup 3 1 roll get /M@t exch store 
          0 exch getinterval /pilem@t exch store } def
/gsave {user {@mpiler} if end gsave macrosgn begin} def
/grestore {user {d@piler @ngleref} if end grestore macrosgn begin} def
/currentpoint{end currentpoint macrosgn begin user {M@t itransform} if } def
/usertrue {/user true store} def
/userfalse {/user false store} def
%% Déterminant d'une matrice
/determ{ 5 dict begin decoupler pop pop /v@2y exch def mul exch v@2y mul exch sub end } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Clipping %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/rogner {newpath x@i y@i moveto x@a y@i lineto x@a y@a lineto x@i y@a lineto 
                closepath clip newpath} def %OK

/debutrognage {gsave cercle? {calculcercle} if 
                          newpath dup length /n@mbr exch store 
                          dup 0 get decoupler moveto
                          1 1 n@mbr 1 sub {exch dup 3 -1 roll get decoupler lineto} for
                          closepath pop clip} def

/finrognage {grestore} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Dessin éventuel d'une grille ou d'un quadrillage dans la fenêtre
/reseau {x@i st@x x@a {y@i st@y y@a {exch dup 3 -1 roll accoupler point} for  pop } for} def %OK

/quadrillage { x@i st@x x@a {dup y@i moveto y@a lineto stroke} for
                          y@i st@y y@a {dup x@i exch moveto x@a exch lineto stroke} for
                          } def %OK

/quadrillagetirete {traittirete x@i st@x x@a {dup y@i moveto y@a lineto stroke} for
                    y@i st@y y@a {dup x@i exch moveto x@a exch lineto stroke} for
                    traitplein} def %OK


/reseautriangulaire{/v@1 1x st@x mulp store /v@2 v@1 60 rota store
                 st@x 3 sqrt mul 2 div  /st@yy exch store              
                 x@i 2 mul x@a sub st@x div floor 1 x@a 2 mul x@i sub st@x div floor {/x@x exch store 
                 y@i st@yy div floor 1 y@a st@yy div floor 1 add {
                  x@x exch accoupler triangverscar dup dansdomaine? {point}{pop} ifelse} for } for
}def

/triangulation {/v@1 1x st@x mulp store /v@2 v@1 60 rota store /v@3 v@2 60 rota store
                 st@x 3 sqrt mul 2 div  /st@yy exch store              
                 x@i 2 mul x@a sub st@x div floor 1 x@a 2 mul x@i sub st@x div floor  
                 {v@1 exch mulp dup dup v@2 addp accoupler droite dup v@3 addp accoupler droite } for
                 y@i st@yy div floor 1 y@a st@yy div floor 1 add 
                 {0 exch accoupler triangverscar [origine 1x] droiteparall} for
} def   

/triangverscar {/v@1 1x st@x mulp store /v@2 v@1 60 rota store
                v@1 v@2 3 2 roll decoupler combili} def

/graduercoordtriang{x@i st@x div floor cvi 1 x@a st@x div floor cvi  
                  {st@x mul dup str espacer exch [ exch 0] triangverscar [0 -0.2] addp etiqhorcc} for
                  st@x 3 sqrt mul 2 div  /st@yy exch store              
                  y@i st@yy div floor cvi 1 y@a st@yy div floor cvi 1 add       
                  {st@x mul dup str espacer exch [ 0 3 2 roll ] triangverscar etiqhorg} for } def   

/reseauhexagonal{/st@yy st@x 3 sqrt mul 2 div store
               /d@b x@i 2 mul x@a sub st@x div floor store
               /f@n x@a 2 mul x@i sub st@x div floor 1 add store
               y@i st@yy div floor 1 y@a st@yy div floor 1 add
               {/@rd exch store
                d@b 3 f@n {dup @rd accoupler triangverscar 
                           dup dansdomaine? {exch 1 add @rd accoupler triangverscar 6 
                                             3 array astore polregsommets {dup dansdomaine? {point} {pop}ifelse} forall}
                                            {pop pop} ifelse} for
                /d@b d@b 2 sub store /f@n f@n 1 sub store
                } for

 } def

/hexagonation {/st@yy st@x 3 sqrt mul 2 div store
               /d@b x@i 2 mul x@a sub st@x div floor store
               /f@n x@a 2 mul x@i sub st@x div floor 1 add store
               y@i st@yy div floor 1 y@a st@yy div floor 1 add
               {/@rd exch store
                d@b 3 f@n {dup @rd accoupler triangverscar 
                           dup dansdomaine? {exch 1 add @rd accoupler triangverscar 6 
                                                                  3 array astore polreg}
                                            {pop pop} ifelse} for
                /d@b d@b 2 sub store /f@n f@n 1 sub store
                } for
} def

/reseaupolaire {  0 st@x x@a abs x@i abs floor max 
                  {[ exch origine exch 1x exch mulp 36] polregsommets suitepoints } for
} def

/polarisation {   0 st@x x@a abs x@i abs max floor dup /n@@ exch store
                  {[exch origine exch 1x exch mulp] cerclecp} for
                  [origine 1x n@@ mulp 36] polregsommets {[ exch origine ] segment } forall
} def

/carverspol {dup norme exch anglepolaire accoupler} def  %%[x y] -> [r \theta]

/polverscar {decoupler 
             2 copy cos mul 3 1 roll sin mul accoupler} def %% [r \theta] -> [x y] 

/graduercoordpolaires {0 st@x x@a abs x@i abs max floor dup /n@@ exch store
                  {dup str espacer ( ) concatener exch 0 accoupler polverscar etiqhorg} for
                  0 10 80 {dup ( ) exch str concatener exch n@@ exch accoupler polverscar etiqhord} for
                  (90)[n@@ 90] polverscar [0 st@x 4 div] addp etiqhorcc
                  100 10 260 {dup str ( ) concatener exch n@@ exch accoupler polverscar etiqhorg} for
                  (270)[n@@ 270] polverscar [0 st@x 4 div] subp etiqhorcc
                  280 10 350 {dup ( ) exch str concatener exch n@@ exch accoupler polverscar etiqhord} for
} def 
 
%% Calcul de l'épaisseur du trait
/epaisseur {eptr@ setlinewidth} def %OK
/fixeepaisseurtrait {/eptr@ exch CoeffAjust mul store} def
/epaisseurtrait {eptr@} def

%% Dessin du cadre et/ou des axes
/fixeposy {/xp@sy exch store} def
/fixeposx {/yp@sx exch store} def

/cadre{[[x@i y@i][x@a y@a]] rectanglediag} def
/cadrerempli {[[x@i y@i][x@a y@a]] rectanglediagrempli} def

/origine {[0 0]} def  
/1x [1 0] store
/1y [0 1] store


/axes  {  epaisseur
          xp@sy [x@i  x@a] dans? {xp@sy y@i moveto xp@sy y@a lineto 
          stroke  xp@sy y@a moveto  90  tip}if 
          yp@sx [y@i  y@a] dans? {x@i yp@sx moveto x@a yp@sx lineto 
          stroke x@a yp@sx moveto 0 tip} if
          } def %OK

/fixelongueurmarques {/l@trait exch store} def
/traitvert {newpath moveto userfalse 0 l@trait 2 div rmoveto 0 l@trait neg rlineto stroke usertrue} def %OK
/traithor {newpath moveto userfalse l@trait 2 div 0 rmoveto l@trait neg 0 rlineto stroke usertrue} def %OK
/traitobli {newpath moveto userfalse l@trait 2 sqrt 4 div mul dup rmoveto l@trait 2 sqrt 2 div mul neg dup rlineto stroke usertrue} def %OK
/marqueverti {/traitvert marque} def
/marqueobli {/traitobli marque} def
/marquehori {/traithor marque} def
/marque {/l@trait l@trait 2 mul store 3 1 roll pointsurdroitegraduee decoupler 
         3 -1 roll cvx exec /l@trait l@trait 2 div store} def

/fixepasgraduationx {/st@x exch store} def %OK
/fixepasgraduationy {/st@y exch store} def %OK
/graduercadre{alph  x@i st@x x@a {dup y@i traitvert
                       dup str espacer exch y@i accoupler 0 talph@ 0.66 mul M@t idtransform 
                       accoupler subp etiqhorcc} for 
                       y@i st@y y@a {dup x@i exch traithor
                        dup str espacer ( ) concatener
                        exch x@i exch accoupler etiqhorg} for} def

/gradueraxey {alph  y@i st@y y@a l@bely {st@y sub} if {dup xp@sy exch traithor
                       dup 0 eq {pop}{dup str espacer ( ) concatener 
                       exch xp@sy exch accoupler etiqhorg} ifelse} for} def

/gradueraxex {alph x@i st@x x@a l@belx {st@x sub} if {dup yp@sx traitvert
                       dup str espacer exch yp@sx accoupler 0 talph@ 0.66 mul M@t idtransform 
                       accoupler subp etiqhorcc} for } def

/gradueraxes {gradueraxex gradueraxey} def

% Etiquettes sur les axes 

/etiqx { x@a yp@sx accoupler 0 talph@ 0.66 mul M@t idtransform accoupler subp etiqhorcc /l@belx true store} def
/etiqy {xp@sy y@a accoupler etiqhorg /l@bely true store } def %OK
/etiqsymbx { x@a yp@sx accoupler 0 talph@ 0.66 mul M@t idtransform accoupler subp etiqsymbhorg /l@belx true store} def
/etiqsymby {xp@sy y@a accoupler etiqsymbhorg /l@bely true store } def %OK


/etiquettes {(X) etiqx (Y) etiqy} def %OK

%% Sélection d'une police de caractères

/fixepolice {/alph@ exch store alph@ dup NLSVec ReEncode} def %OK
/fixepolicesymbolique {/symbalph@ exch store} def %OK
/fixecorps {/talph@ exch CoeffAjust mul store} def %OK

%% Police pour texte 
/@lphnorm {findfont talph@ scalefont setfont} def
/@lphret{findfont [talph@ 0 0 talph@ neg 0 0] makefont setfont} def
/@lphhom{findfont [talph@ r@pp mul 0 0 talph@ r@pp mul 0 0] makefont setfont} def
/alph {alph@ @lphnorm} def %OK
/alphret {alph@ @lphret} def %OK
/alphhom{alph@ @lphhom} def
%% Police pour symboles 
/alphsymb{symbalph@ @lphnorm} def %OK
/alphsymbret {symbalph@ @lphret} def %OK
/alphsymbhom{symbalph@ @lphhom} def

%% Ecritures d'étiquettes avec point de référence à gauche, à droite puis au centre 

/@ng 0 store
 
/leverdr@ps{dr@pdessin {dr@psym {alphret} {dr@phom{alphhom}{alph}ifelse} ifelse} {alph} ifelse} def
/leverdr@psymb{dr@pdessin {dr@psym {alphsymbret} {alphsymb} ifelse} {alphsymb} ifelse} def
/@ngletiupdate{dr@pdessin {dr@prot {/@ngleti @ngleti @ngrot add store} if 
                                  dr@psym {/@ngleti dr@ite decoupler exch subp anglepolaire 2 mul @ngleti sub store} if
                                  } if } def

/etiq1 {@ngletiupdate decoupler moveto} def
/etiq2 {show  angleref neg rotate usertrue currentpoint  grestore  moveto } def
/etiqd {etiq1   gsave @ngleti rotate  userfalse  angleref rotate   etiq2}   def
/etiqhord {0 etiqobliqued} def
/etiqverh {90 etiqobliqued} def %OK
/etiqobliqued{leverdr@ps /@ngleti  exch store etiqd}  def % ch ang pt etiqobliqued
/etiqsymbhord {0 etiqsymbobliqued} def
/etiqsymbverh {90 etiqsymbobliqued} def %OK
/etiqsymbobliqued{leverdr@psymb /@ngleti  exch store etiqd}  def % ch pt ang  etiqobliqued

/etiqg {etiq1 dup stringwidth pop neg 0 gsave @ngleti rotate userfalse angleref rotate rmoveto etiq2} def
/etiqhorg {0 etiqobliqueg} def
/etiqverb {90 etiqobliqueg} def %OK
/etiqobliqueg{ leverdr@ps /@ngleti  exch store etiqg}  def % ch pt ang  etiqobliqued
/etiqsymbhorg {0 etiqsymbobliqueg} def
/etiqsymbverb {90 etiqsymbobliqueg} def %OK
/etiqsymbobliqueg{leverdr@psymb /@ngleti  exch store etiqg}  def % ch ang pt etiqobliqueg

/etiqc {etiq1 dup stringwidth pop 2 div neg 0  gsave @ngleti rotate userfalse angleref rotate  rmoveto etiq2} def
/etiqhorc {0 etiqobliquec} def
/etiqverc {90 etiqobliquec} def %OK
/etiqobliquec{ leverdr@ps /@ngleti  exch store etiqc}  def % ch pt ang  etiqobliqued
/etiqsymbhorc {0 etiqsymbobliquec} def
/etiqsymbverc {90 etiqsymbobliquec} def %OK
/etiqsymbobliquec{leverdr@psymb /@ngleti  exch store etiqc}  def % ch ang pt etiqobliqueg

/etiqcc {etiq1 dup  gsave true charpath pathbbox exch   3 1 roll sub 2 div  3 1 roll sub 2 div exch grestore  gsave @ngleti rotate userfalse angleref rotate rmoveto etiq2}  def
/etiqhorcc {0 etiqobliquecc} def
/etiqvercc {90 etiqobliquecc} def %OK
/etiqobliquecc{ leverdr@ps /@ngleti  exch store etiqcc}  def % ch pt ang  etiqobliqued
/etiqsymbhorcc {0 etiqsymbobliquecc} def
/etiqsymbvercc {90 etiqsymbobliquecc} def %OK
/etiqsymbobliquecc{leverdr@psymb /@ngleti  exch store etiqcc}  def % ch ang pt etiqobliqueg






%% Concaténation de deux chaines -- Syntaxe : s1 s2 concatener. Le résultat est sur la pile
/concatener { /s@2 exch def /s@1 exch def s@1 length dup /l@1 exch def 
              s@2 length add string /s@ exch def s@ 0 s@1 putinterval s@ l@1 s@2 putinterval s@} def %OK
/concate {1 sub {concatener} repeat} def %OK concatenation de plus de deux chaines
  % syntaxe ch1 ch2 ... chn n concate résultat sur la pile

%% Concaténation de deux tableaux -- Syntaxe : t1 t2 append. Le résultat est sur la pile
/append { /s@2 exch def /s@1 exch def s@1 length dup /l@1 exch def 
              s@2 length add array /s@ exch def s@ 0 s@1 putinterval s@ l@1 s@2 putinterval s@} def %OK
/appe {1 sub {append} repeat} def %OK concatenation de plus de deux tableaux
  % syntaxe t1 t2 ... tn n appe résultat sur la pile
/ret@urner {/tab@ri exch store tab@ri length 1 sub /n@ exch  store n@  1 add array /tabf@n exch store 0 1 n@  {tab@ri n@  2 index  sub get tabf@n 3 1 roll  put} for tabf@n } def
%% Dessin d'un point 

% Formes possibles :
		   % /dot, /pavetriangle, /pavecarre, /pavepentagone
		   % /pavehexagone  /etoile5 /etoile6
		   % /croix /pavelosange /paverectangle 
               % A l'exception de "croix", ces formes sont remplies

/dotp@l{decoupler 1y exch mulp exch decoupler M@t transform accoupler dup 3 -1 roll addp 
        nc@t 3 array astore userfalse polregrempli usertrue} def
/dot{newpath decoupler /r@yon exch store decoupler M@t transform userfalse r@yon 0 360 arc fillstroke usertrue} def 
/pavetriangle{/nc@t 3 store dotp@l} def
/pavelosange{decoupler  exch  decoupler M@t transform accoupler /pr@vpt exch store 
                       dup 1x exch 0.5 mul mulp  exch dup 1y exch mulp exch  dup 1x exch -0.5 mul mulp exch 1y exch neg  mulp 4 array astore
                      { pr@vpt addp} forall 4 array astore userfalse polygonerempli usertrue } def %OK
/pavepentagone{/nc@t 5 store dotp@l} def %OK
/pavehexagone{/nc@t 6 store dotp@l} def %OK
/pavecarre{decoupler [1 1] exch mulp exch decoupler M@t transform accoupler dup 3 -1 roll addp 
           4 3 array astore userfalse polregrempli usertrue} def
/etoile5{decoupler [0 1.5] exch mulp exch decoupler M@t transform accoupler dup 3 -1 roll addp 
         5 2 4 array astore userfalse poletoilerempli usertrue} def
/etoile6{decoupler [0 1.5] exch mulp exch decoupler M@t transform accoupler dup 3 -1 roll addp 
         6 2 4 array astore userfalse poletoilerempli usertrue} def
/croix{decoupler 1y exch mulp exch decoupler M@t transform accoupler dup 3 -1 roll addp 
       4 2 4 array astore userfalse poletoilesommets decoupler segment segment usertrue} def %OK
/paverectangle{decoupler exch decoupler M@t transform accoupler exch 
               n@m 0 eq {[1 2 sqrt] exch mulp 2 copy subp 3 1 roll addp accoupler 
                         userfalse rectanglediagrempli usertrue}
                  {pop 2 index str newpath 0 0 moveto true charpath pathbbox 3 -1 roll sub 
                 3 1 roll exch sub exch accoupler 2 divp [diamdot dup] addp 
                 2 copy subp 3 1 roll addp accoupler userfalse rectanglediagrempli usertrue}
                 ifelse } def %OK

/fixetaillepoint {/diamdot exch CoeffAjust mul store} def
/fixeformepoint{/f@pt exch store} def %OK
/exef@pt {accoupler f@pt cvx exec } def %
/point{suitepoints} def
/pointpasnomme {/n@m 0 store diamdot exef@pt} def 
/pointnomme {alph /n@m 1 store dup cvx exec exch 
                dup str dup (i) exch (i) 3 concate diamchaine dup diamdot lt
                {pop diamdot}if 4 -1 roll exch exef@pt exch cvx exec etiqhorcc} def 
   
%% Dessin d'une suite de points  -- Syntaxe [[x1 y1] [x2 y2] ... [xn yn]] suitepoints

/suitepoints{nom? {pointnomme}{point? {pointpasnomme}{{suitepoints} forall}ifelse}ifelse} def

/abscisse{decoupler pop} def % p abscisse OK
/ordonnee{decoupler exch pop} def % p ordonnee OK
/rota {/@ngle exch store decoupler [ @ngle cos @ngle sin @ngle sin neg @ngle cos 0 0]
        transform accoupler} def
         % image d'un point par une rotation: syntaxe point angle rota OK
/addp {decoupler 3 2 roll decoupler exch 4 1 roll exch add 3 1 roll add exch accoupler} def
    % OK
/subp {decoupler 3 2 roll decoupler exch 4 1 roll exch sub 3 1 roll sub exch accoupler} def
    % OK
/scalp {decoupler 3 2 roll decoupler exch 4 1 roll mul 3 1 roll mul add} def
    % OK
/mulp {exch decoupler 2 index mul 3 1 roll mul exch accoupler} def % syntaxe [x y] k mulp 
   % OK
/divp {1 exch div mulp} def %OK
/vectp {decoupler 1 index subp  3 1 roll subp exch 1 index abscisse 1 index ordonnee mul 
           3 1 roll abscisse exch ordonnee mul sub} def
  % [a b c] vectp --> composante en z du produit vectoriel (a-b)^(c-b) sert à déterminer l'orientation du triplet [a b c]
/anglepolaire {decoupler  exch atan} bind def %% a  anglepolaire --> anglepol du vecteur a entre 0 et 360

/norme {decoupler dup mul exch dup mul add sqrt} def
   % OK

/normer {dup norme divp} def
   % OK
/combili {exch 4 1 roll mulp 3 1 roll exch mulp addp} def %  p1 p2 a b -> ap1+bp2
   % OK
/pointsurdroitegraduee {exch decoupler 3 -1 roll dup 1 exch sub exch combili} def % [p1 p2] t -> (1-t)p1+tp2

/isobarycentre {dup length exch origine exch {addp} forall exch  divp} def
/milieu {isobarycentre} def

%% Segments et flèches
/fixeformesegment{/fs@g exch store} def

/nametoexec{/nametype {cvx exec} def /arraytype {} def /integertype {} def /realtype {} def
            [ exch {dup type cvx exec} forall ] } def

/dep@rt {rayoncoin 0 eq cl@ not or 
                        {st@rt} 
                        {[l@st st@rt d@ux] amplitude d@ux st@rt subp normer  exch  2 div  cotg abs rayoncoin abs mul mulp 
                         st@rt addp } ifelse} def

/openpath {nametoexec aload dup  length  1 sub  /n@brs@m exch  store 
                      0 get /l@st exch store   /st@rt exch store  dup  /d@ux exch store 
                      dep@rt  desassembler moveto 
                     1 1 n@brs@m  { fs@g cvx exec} for  } def %OK

/cl@ false store

/segmentdroit {pop decoupler lineto} def
/segmentarrondi {exch  /c@in exch store /dr@p 0 store
                  dup 0 eq {/c@insuiv d@ux store pop}
                                 {n@brs@m eq {cl@ not {/dr@p 1 store} if /c@insuiv st@rt store}  {dup /c@insuiv exch store}ifelse}
                                 ifelse
                  c@in decoupler 
                  dr@p 1 eq {lineto} {c@insuiv decoupler rayoncoin arcto  4  {pop} repeat  }  ifelse 
                  } def  

/closedpath {/cl@ true store openpath  st@rt 0 fs@g cvx exec closepath /cl@ false store } def %OK
           % valable sans devoir indiquer le nombre de cotes

/suitesegments {nonemptyarray? 
                {dup 0 get point? exch pop 
                          {dup length 1 gt {newpath openpath stroke}{pop}ifelse}
                          {{suitesegments} forall} ifelse}
                {pop} ifelse}  def %OK
/suitesegmentspointes{dup nametoexec suitesegments suitepoints} def %OK
/segment {suitesegments} def %OK
/segmentpointe {suitesegmentspointes} def %OK
/suitefleches {/arraytype {} def /nametype {cvx exec} def %OK
          /integertype {pop} def /realtype {pop} def 
          dup [ exch {dup type cvx exec} forall] suitesegments 
          /integertype {} def /realtype {} def
	    [ exch {dup type cvx exec} forall]
          aload length 1 sub 2 div cvi 
          {3 copy exch 3 1 roll accoupler exch pointsurdroitegraduee 
          decoupler moveto
	    exch pop 1 index subp decoupler M@t dtransform exch atan tip} repeat pop} def
/fleche{suitefleches} def	%OK
/suiteflechespointees{dup suitefleches /arraytype {} def /nametype {} def
          /integertype {pop} def /realtype {pop} def
          [ exch {dup type cvx exec} forall] suitepoints } def %OK
/flechepointee{suiteflechespointees} def %OK

/tip {userfalse angleref add dup rotate currentpoint newpath moveto eptr@ 6 mul neg eptr@ 3 mul rlineto 
      eptr@ 1.5 mul eptr@ 3 mul neg rlineto eptr@ 1.5 mul neg eptr@ 3 mul neg rlineto
      closepath c@ltrait fixcolor end fill macrosgn begin neg rotate usertrue} def %OK

/sp@l{dup  0 get point? exch pop {closedpath}  {{sp@l} forall} ifelse }def
/polygone{suitepolygones} def %OK
/suitepolygones{newpath sp@l stroke} def
/polygonepointe{dup nametoexec polygone suitepoints} def %OK
/polygoneoriente{/arraytype {} def /nametype {cvx exec} def %OK
          /integertype {pop} def /realtype {pop} def 
          dup [ exch {dup type cvx exec} forall] polygone 
          /integertype {} def /realtype {} def 
	    [ exch {dup type cvx exec} forall]
	    aload length dup index exch 1 add 2 div cvi  	
          {3 copy exch 3 1 roll accoupler exch pointsurdroitegraduee decoupler moveto
	    exch pop 1 index subp decoupler exch atan orientationpointe add tip} repeat pop} def
/polygonepointeoriente{dup polygoneoriente /arraytype {} def /nametype {} def
          /integertype {pop} def /realtype {pop} def
          [ exch {dup type cvx exec} forall] suitepoints } def %OK
/polygonerempli{suitepolygonesremplis} def %OK
/r@mplir{ userfalse moderemplissage 2 eq 
          {gsave stroke grestore full} {gsave full grestore stroke} ifelse
          usertrue} def
/suitepolygonesremplis{newpath sp@l r@mplir}def
/polygonepointerempli{dup nametoexec polygonerempli suitepoints } def %OK
/polygoneorienterempli{/arraytype {} def /nametype {cvx exec} def %OK
          /integertype {pop} def /realtype {pop} def 
          dup [ exch {dup type cvx exec} forall] polygonerempli
          /integertype {} def /realtype {} def
	    [ exch {dup type cvx exec} forall]
	    aload length dup index exch 1 add 2 div cvi  	
          {3 copy exch 3 1 roll accoupler exch pointsurdroitegraduee decoupler moveto
	    exch pop 1 index subp decoupler exch atan tip} repeat pop} def
/polygonepointeorienterempli{dup polygoneorienterempli /arraytype {} def /nametype {} def
          /integertype {pop} def /realtype {pop} def
          [ exch {dup type cvx exec} forall] suitepoints } def %OK



%% Etoiles régulières Syntaxe: [Centre Un_sommet Nbre_de_sommets Intervalle_entre_deux_sommets] etoile...
/poletoilesommets {decoupler /int@r exch store /n@bre exch store /s@mm exch store /c@ntr exch store 
                                                360 n@bre div int@r mul /@ngrot exch store n@bre int@r pgcd  /r@p exch  store 
                                               r@p 1 eq {[ s@mm  n@bre 1 sub {dup r@t1} repeat ]}        
                                                               { [ r@p  {[ s@mm n@bre r@p idiv 1 sub  {dup r@t1} repeat ] 
                                                                  s@mm  c@ntr subp  360 n@bre div  rota c@ntr addp  /s@mm exch store } repeat ]} ifelse 
                                   }   def 	%OK

/poletoile {poletoilesommets suitepolygones} def %OK
/poletoilerempli{poletoilesommets polygonerempli} def
/poletoilepointe {dup 0 get point nametoexec poletoilesommets dup suitepolygones suitepoints } def %OK
/poletoilepointerempli {dup nametoexec poletoilesommets dup suitepolygonesremplis  suitepoints  0 get point} def  %OK

%% Polygones réguliers Syntaxe: [Centre Un_sommet Nbre_de_sommets] polreg...

/polregsommets{decoupler 3 -1 roll  (Rn) fixerosace Rn} def    %OK
/polreg {polregsommets polygone} def %OK
/polregrempli {polregsommets polygonerempli} def %OK
/polregpointe {dup 0 get point nametoexec polregsommets dup suitepolygones suitepoints} def
/polregpointerempli {dup nametoexec polregsommets dup suitepolygonesremplis  suitepoints  0 get point} def  %OK

/affectervaleurs {/suites@m exch store /suiten@ms exch store
        0 1 suites@m length 1 sub {dup suiten@ms exch get exch suites@m exch get store} for
        } def

%% Rectangles

% Rectangles définis par une diagonale. Syntaxe: [a b] rectanglediag
/rect@ngledi@g {decoupler /c@sg exch store /c@sd exch store /c@id exch store /c@ig exch store 
                [c@ig c@sg c@sd c@id] suitesegments} def
/rectanglediagsommets{decoupler decoupler /ury exch def /urx exch def decoupler/lly exch def /llx exch def
           [[llx lly] [urx lly]  [urx ury]  [llx ury]]} def %OK
/rectanglediag{rectanglediagsommets polygone} def %OK
/rectanglediagpointe{rectanglediagsommets polygonepointe} def %OK
/rectanglediagrempli{rectanglediagsommets polygonerempli} def %OK
/rectanglediagpointerempli{rectanglediagsommets polygonepointerempli} def %OK

% Rectangles définis par une médiane. Syntaxe: [[a b] largeur] rectanglemed 
/rectanglemedsommets{decoupler 2 div exch dup vecnorperp 3 -1 roll mulp exch decoupler 2 copy 
                     4 index addp exch 4 index addp 5 -3 roll exch 2 index subp 
                     3 1 roll exch subp 4 array astore} def %OK
/rectanglemed{rectanglemedsommets polygone} def %OK
/rectanglemedpointe{rectanglemedsommets polygonepointe} def %OK
/rectanglemedrempli{rectanglemedsommets polygonerempli} def %OK
/rectanglemedpointerempli{rectanglemedsommets polygonepointerempli} def %OK

%%%%%%%%%%%%%%Cercles%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Les instructions  cercle et  arccercle tracent d'abord un trait du point courant  jusqu'au point de départ du cercle  
%%%% ou de l'arc de cercle. Les instructions calculcercle et calcularccercle retournent une suite de points 
%%%% constituant le cercle ou l'arc.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


/r@nd{decoupler exch /c@ntrelli exch store  dup 1x exch mulp c@ntrelli addp  /v@1 exch store  1y exch mulp c@ntrelli addp /v@2 exch store 
            /s@ns 1 store 0 360 @rcellip } def 
                                                  % centre rayon r@nd %OK

/cercleversellipse {decoupler  dup 1x exch mulp 2 index addp exch  1y exch mulp 2 index addp 3 array astore} def

/suitedisques{cercle? {newpath r@nd fillstroke}
                                   {droite? {droite}{ {suitedisques } forall } ifelse} 
                                   ifelse} def %OK
/disque{suitedisques}def
/suitecercles{cercle? {newpath r@nd stroke}
                                  {droite?  {droite} { {suitecercles} forall } ifelse} 
                                  ifelse} def %OK

/cercle{suitecercles} def

/arccercleversarcellipse {desassembler  /extr@2 exch store /@nterm exch store /v@1 exch store [v@1 @nterm] mediatrid [extr@2 @nterm] mediatrid
                                         interdroites  pop  
                                        /c@ntrelli exch store  [v@1 c@ntrelli @nterm] vectp signe /s@ns exch store 
                                          /v@2 v@1  90  c@ntrelli rotation store
                                         [ [c@ntrelli v@1 v@2]  0 [v@1 c@ntrelli extr@2] amplitude s@ns 0 lt  {360  sub} if  s@ns ]} def
                               
/arccercle {desassembler  /extr@2 exch store /@nterm exch store /v@1 exch store [v@1 @nterm] mediatrid [extr@2 @nterm] mediatrid
                                         interdroites 
                                         {/c@ntrelli exch store  [v@1 c@ntrelli @nterm] vectp signe /s@ns exch store 
                                          /v@2 v@1  90  c@ntrelli rotation store
                                          0 [v@1 c@ntrelli extr@2] amplitude s@ns 0 lt  {360  sub} if  @rcellip stroke}
                                         {@nterm [v@1 extr@2] danssegment? 
                                                                 {[v@1 extr@2] segment} 
                                                                 {v@1 [@nterm extr@2] danssegment? not {v@1 /extr@1 extr@2 store /extr@2 exch store} if
                                                                           [v@1 @nterm] demidroite [extr@2 dup 2 mulp v@1 subp] demidroite} 
                                                                 ifelse } 
                                          ifelse } def
/calculcercle {cercleversellipse calculellipse} def
/calcularccercle{arccercleversarcellipse calcularcellipse} def

%%% arcsecteur calcule l'arc de cercle associé à un secteur et un rayon. Syntaxe [[a b c] r] arcsecteur --> [p1 p2 p3]
%%% dessin dans le sens trigo si r> 0 inverse sinon
%%% L'amplitude est toujours positive. Angle de [ba vers [bc

/amplitude{desassembler 1 index subp anglepolaire  3 1 roll   subp anglepolaire  sub 
                      dup 0 lt {360 add} if} def

/arcsecteur {decoupler /@r1 exch store  dup amplitude @r1 0 lt {360 sub} if 2 div  /@ngrot exch store 
                   desassembler pop dup /c@ntr exch store  subp normer  @r1 abs mulp c@ntr addp    
                    dup r@t1 dup  r@t1 3 assembler} def

/arccerclesecteur {arcsecteur arccercle} def

/sectcirc@ {desassembler  /extr@2 exch store /@nterm exch store /extr@1 exch store [extr@1 @nterm] mediatrid [extr@2 @nterm] mediatrid
                                         interdroites 
                                         {/c@ exch store c@ decoupler 2 copy moveto [c@ extr@1] distance  extr@1 c@ subp anglepolaire extr@2 c@ subp anglepolaire 
                                           2 copy gt {exch} if 2 copy accoupler @nterm c@ subp anglepolaire exch dans? {arc}{arcn} ifelse closepath}  if} def            

/secteurcercle{sectcirc@ stroke} def

/secteurdisque {sectcirc@ fillstroke} def

%%%%%%%%%%%%%% Ellipses%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Les instructions  ellipse et arcellipse tracent d'abord un trait du point courant  jusqu'au point de départ 
%%%% de l'ellipse ou de l'arc d'ellipse. Les instructions calculellipse et calcularcellipse retournent une suite 
%%%% de points constituant l'ellipse ou l'arc.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/fixe@llipse{desassembler  /v@2 exch store /v@1 exch store  /c@ntrelli exch store } def

/@rcellip{ /bet@ exch store /@lpha exch store
                  s@ns 0 gt {bet@ @lpha lt {/bet@ bet@ 360 add store} if}{@lpha bet@ lt {/@lpha @lpha 360 add store} if} ifelse
                  @lpha p@intellipse  decoupler   {lineto} stopped  {moveto macrosgn begin } if
                  @lpha  s@ns 0 gt {1}{-1} ifelse   bet@  {p@intellipse decoupler lineto}  for} def

/calcularcellipse{desassembler /s@ns exch store   /bet@ exch store /@lpha exch store fixe@llipse
                  s@ns 0 gt {bet@ @lpha lt {/bet@ bet@ 360 add store} if}{@lpha bet@ lt {/@lpha @lpha 360 add store} if} ifelse
                  [  @lpha  s@ns 0 gt {1}{-1} ifelse   bet@  {p@intellipse }  for ]}  def

/arcellipse{arcellipsebis stroke} def
%%%% arcellipsebis est nécessaire pour chemin 
/arcellipsebis{desassembler  /s@ns exch store 3 2 roll  fixe@llipse  @rcellip} def

/tr@ceellipse {newpath fixe@llipse 0 360  /s@ns 1 store @rcellip} def

%%%%%% Point sur Ellipse  E alpha pointsurellipse %%%%%%%%%%%%
/p@intellipse {/@ngl exch store v@1 c@ntrelli subp v@2 c@ntrelli subp @ngl cos  @ngl sin  combili c@ntrelli addp} def
/pointsurellipse {exch fixe@llipse p@intellipse } def
/ellipse {tr@ceellipse stroke} def
/calculellipse {0 360  1 4 array astore  calcularcellipse} def

/suiteellipses {nonemptyarray? 
                {dup tripoint? exch pop 
                          {tr@ceellipse stroke}
                          {{suiteellipses} forall} ifelse}
                {pop} ifelse}  def 

/ellipseremplie {tr@ceellipse fillstroke} def

/suiteellipsesremplies {nonemptyarray? 
                {dup tripoint? exch pop 
                          {tr@ceellipse fillstroke}
                          {{suiteellipsesremplies} forall} ifelse}
                {pop} ifelse}  def 



/p@stip {c@ntre  [0 r@yon] addp decoupler moveto} def
/cercleorientepos {dup decoupler /r@yon exch store  /c@ntre exch store cercle p@stip 180 tip} def
/cercleorienteneg {dup decoupler /r@yon exch store  /c@ntre exch store cercle p@stip 0 tip } def
/disqueorientepos {dup decoupler /r@yon exch store  /c@ntre exch store disque p@stip 180 tip } def
/disqueorienteneg {dup decoupler /r@yon exch store  /c@ntre exch store disque p@stip 0 tip} def
/cerccp{dup distance exch decoupler pop exch accoupler} def
/cerclecp{cerccp cercle} def
/cerc3p{/trip exch store trip decoupler 3 copy accoupler mediatrid 4 1 roll accoupler mediatrid exch pop 
        interdroites {exch 1 index accoupler distance accoupler}
                           {pop trip decoupler pop accoupler} ifelse} def % [a b c] cerc3p -> [centre rayon] ou couple de deux points
/cercle3p{cerc3p cercle} def
/pointsurcerccp {/@ngl exch store  decoupler 1 index subp @ngl rota addp} def 
      % [centre point] angle pointsurcerccp -> point

% Intersection d'une droite et d'un cercle
/droiteintercercle{decoupler /r@y exch store dup 2 index projection dup /pr@j exch store
                   accoupler distance dup /dist@ exch store r@y gt
                   {pop false}
                   {vecnorparall  r@y dup mul dist@ dup mul sub sqrt mulp dup pr@j addp
                    exch pr@j exch subp accoupler true} ifelse} def %OK
                % Syntaxe: droite cercle droiteintercercle -> [a1 a2] true ou false
                                      
/pointinter2drcerc{decoupler pop 1 index projection 2 mulp exch decoupler pop subp} def

/distance {decoupler subp norme} def %OK

% Intersection de deux cercles [c1 r1] et [c2 r2]
/axeradical {decoupler dup mul 3 -1 roll decoupler dup mul exch 3 1 roll exch sub
             3 copy pop accoupler distance dup dup mul exch 3 1 roll add 2 div exch div
             3 1 roll accoupler dup vecnorparall 3 -1 roll mulp exch dup 1 get 3 -1 roll
             addp exch perpd} def %OK
/intercercles {1 index axeradical exch droiteintercercle} def %OK
               % Syntaxe: [c1 r1] [c2 r2] intercercles -> [a1 a2] true ou false

                
% Syntaxe p [c1 r1] [c2 r2] pointinter2cerccerc
/pointinter2cerccerc{decoupler pop exch decoupler pop accoupler 1 index exch projection 2 mulp 
exch subp} def

%% Secteurs angulaires
%% syntaxes [b a c] secteur 
/secteurangulaire {decoupler 1 index exch accoupler demidroite exch accoupler demidroite} def


%% amplitude calcule l'amplitude (en degrés) d'un angle  orienté [a b c] secteur amplitude -> anglepolaire ba - anglepolaire bc (nombre entre 0 et 360)
%% rotation qui applique [ba] sur [bc]



/camembert {decoupler /r@ exch store /c@ exch store /c@uleurs exch store /pr@p exch store
            c@ 1x r@ mulp addp /dep@ exch store
            0 1 pr@p length 1 sub {dup c@uleurs exch get fixecouleurfond 
                       pr@p exch get 360 mul [c@ dep@] exch pointsurcerccp /fin@ exch store
                       [ [ dep@ c@ fin@ ] r@] arcsecteur secteurdisque /dep@ fin@ store } for } def


/cercto@llip {5 -2 roll accoupler /c@ntrelli exch store 3 2 roll dup 0 accoupler c@ntrelli addp /v@1 exch store  0 exch accoupler c@ntrelli addp  /v@2 exch store } def

/arccerclebis {desassembler /extr@2 exch store /@nterm exch store /extr@1 exch store 
                                         [extr@1 @nterm]  mediatrid  [extr@2 @nterm] mediatrid interdroites  
                                         {/c@ exch store c@ [c@ extr@1] distance dup 1x exch mulp c@ addp exch 1y exch mulp c@ addp 3 assembler fixe@llipse
                                          extr@1 c@ subp anglepolaire extr@2 c@ subp anglepolaire  
                                          [extr@1 c@ extr@2] vectp signe /@r1 exch store [extr@1 c@ @nterm] vectp signe /@r2 exch store 
                                          [@nterm c@ extr@2] vectp signe /@r3 exch store
                                          @r1 0 ne {@r2 0 eq {@r3} {@r3 0 eq{@r2} { @r1 dup  @r2 eq { @r1 @r3 ne {neg} if}  {neg} ifelse} ifelse} ifelse}
                                                         {@r2} ifelse /s@ns exch store 
                                           @rcellip}
                                         {@nterm   [extr@1  extr@2] danssegment? 
                                                                 {extr@1 decoupler lineto extr@2 decoupler lineto} 
                                                                 {extr@1 [@nterm extr@2] danssegment? not {extr@1 /extr@1 extr@2 store /extr@2 exch store} if
                                                                           [extr@1 @nterm] demidroitebis decoupler moveto decoupler lineto 
                                                                           [extr@2 dup 2 mulp extr@1 subp] demidroitebis exch decoupler moveto decoupler lineto } 
                                                                 ifelse } 
                                          ifelse } def



/openchemin{dup length  /l@n exch store
            dup 0 get point? {decoupler moveto} 
                                       {dup 0 get  point?  {decoupler moveto arccerclebis}  {pop arcellipsebis} ifelse} ifelse
            1 1 l@n 1 sub {exch dup 3 -1 roll get point? {decoupler lineto}{dup 0 get point? {pop arccerclebis} {pop arcellipsebis} ifelse}  ifelse} for
            pop } def

/chemin {newpath openchemin  stroke } def
/lacet{newpath openchemin closepath stroke} def
/lacetrempli{newpath openchemin closepath r@mplir} def
/suitechemins  {nonemptyarray? 
                        {chemin? {chemin} {{suitechemins} forall} ifelse}
                        {pop} ifelse}  def
/suitelacets  {nonemptyarray? 
                        {chemin?  {lacet} {{suitelacets} forall} ifelse}
                        {pop} ifelse}  def 
/suitelacetsremplis  {nonemptyarray? 
                        {chemin? {lacetrempli} {{suitelacetsremplis} forall} ifelse}
                        {pop} ifelse}  def 

% syntaxe  [secteur positionpointe rayon] arcoripos ou arcorineg 
/arc@ri {desassembler /r@y exch store /c@eff exch store /s@c exch store s@c 1 get /c@ntre exch store
              newpath c@ntre s@c decoupler pop subp normer r@y mulp addp decoupler moveto
              s@c 0 get c@ntre subp anglepolaire /@1 exch store
              s@c 2 get c@ntre subp anglepolaire /@2 exch store
              @ri 0 gt {@1 @2 gt {@2 360 add /@2 exch store} if}
                           {@1 @2 lt {@2 360 sub /@2 exch store} if} ifelse
             c@ntre decoupler r@y @1 @2  @ri 0 gt {arc}{arcn} ifelse stroke
             newpath c@ntre @2 @1 sub c@eff mul @1 add /bet@ exch store bet@ dup cos exch sin accoupler r@y mulp addp
             decoupler moveto bet@ 90 @ri 0 gt {add}{sub} ifelse tip
} def

/arcoripos {/@ri 1 store arc@ri} def
/arcorineg {/@ri -1 store arc@ri} def

% flèche incurvée
% syntaxe [ [a positionpointe b] angle ] flechecourbe
	
/flechecourbe {suiteflechescourbes} def

% Suites de flèches courbes
% Syntaxe [ [ a pospointe b pospointe ... m] angle] suiteflechescourbes

/suiteflechescourbes {/arraytype {} def /nametype {cvx exec} def
           /integertype {pop} def /realtype {pop} def
           decoupler /@ng exch store /s@ite exch store
           @ng 180 gt {/@ri 1 store} {/@ri -1 store} ifelse 
           @ng 180 eq {pop}
                               {@ng 0 eq @ng 360 eq or 
                                           {suitefleches} 
                                           {s@ite length 3 sub 2 div /n@bre exch store 
                                                  0 1 n@bre {2 mul /i@ exch store s@ite i@ get dup type cvx exec 
                                                  s@ite  i@ 1 add get /p@s exch store 
                                                  s@ite  i@ 2 add get dup type cvx exec 
			  2 copy exch subp @ng rota origine accoupler 
                                                  2 index exch perpd 3 1 roll 2 copy accoupler mediatrid
                                                  4 -1 roll interdroites pop exch 3 array astore
                                                 dup dup 1 get exch 0 get accoupler distance 
			 p@s exch 3 array astore arc@ri } for 
                                              }ifelse}ifelse} def 


/suiteflechescourbespointees{dup suiteflechescourbes 
           /arraytype {} def /nametype {} def
           /integertype {pop} def /realtype {pop} def
           decoupler pop 
          [ exch {dup type cvx exec} forall] suitepoints } def %OK
/flechecourbepointee{suiteflechescourbespointees} def %OK

/boucle % Syntaxe [a b] boucle a: origine de la boucle, b "deuxième sommet"
   {decoupler tr@nsform /@xtre exch store tr@nsform /@ri exch store userfalse
              @xtre @ri subp 0.5 mulp dup 45 rota /c@ntr1 exch store 
              90 rota /c@ntr2 exch store
              newpath @ri decoupler moveto @ri c@ntr1 addp decoupler 
              @xtre c@ntr2 addp decoupler @xtre decoupler curveto
              @xtre c@ntr2 subp decoupler @ri c@ntr1 -90 rota addp decoupler 
              @ri decoupler curveto closepath stroke usertrue } def


/suiteboucles {nonemptyarray? 
                {dup 0 get point? exch pop 
                                               {boucle}{{suiteboucles} forall} ifelse}
                {pop} ifelse}  def %OK


%% Couleurs

/rouge [1 0 0] store
/vert [0 1 0] store
/bleu [0 0 1] store
/jaune [0 0 1 0] store
/cyan [1 0 0 0] store
/magenta [0 1 0 0] store
/noir [0 0 0 1] store
/blanc [1 1 1] store
/gris [0.7 0.7 0.7] store
/fixecouleurtrait {/c@ltrait exch store} def
/fixecouleurfond {/c@lremp exch store} def
/fixecouleurtexte {/c@lnom exch store} def
/fixecouleurs {dup dup fixecouleurtrait fixecouleurfond fixecouleurtexte} def
/full{moderemplissage 1 eq {eofill} {fill} ifelse} def
/fixemoderemplissage{/moderemplissage exch store} def
/couleurtrait {c@ltrait} def
/couleurfond {c@lremp} def
/couleurtexte {c@lnom} def
/sauvecouleurs {couleurtrait couleurfond couleurtexte 3 array astore /c@uleurs exch store} def
/restaurecouleurs {c@uleurs decoupler fixecouleurtexte fixecouleurfond fixecouleurtrait} def

%% Fonctions arithmétiques

/symb {/carsymb 1 string store carsymb exch 0 exch put carsymb} def %OK crée une chaîne d'un seul 
% caractère à partir du code de celui-ci. syntaxe code symb -> résultat sur la pile
 
/diamchaine {alph newpath 0 0 moveto true charpath pathbbox 3 -1 roll sub abs 
             3 1 roll sub abs 2 copy lt {exch pop}{pop} ifelse 2 div} def

%% Découpage d'un nombre en tranches de 3 chiffres 
/espacer {(.) search 
              {espacerg /str1 exch store pop espacerd  /str2 exch store str2 length 0 gt
                                   {str1 (.) concatener str2 concatener} {str1} ifelse}
              {espacerg} ifelse} def
/espacervirg{(.) search 
              {espacerg pop (,) concatener exch espacerd concatener}
              {espacerg} ifelse} def
/espacerg {dup length /l@n exch store l@n 4 gt 
           {dup 0 l@n 3 sub getinterval exch l@n 3 sub 3 getinterval 
            ( ) exch concatener exch espacerg exch concatener} if } def

/suppzero {dup length 0 gt {dup dup length 1 sub /l@n exch store l@n 1 getinterval (0) eq 
                {0 l@n getinterval suppzero} if} if} def
  
/espacerd {suppzero dup length /l@n exch store l@n 4 gt
           {dup 0 3 getinterval ( ) concatener
            exch 3 l@n 3 sub getinterval espacerd concatener} if} def

/numshow {str espacer show} def %afficher un nombre en y incorporant des blancs

/numvirgshow{str espacervirg show} def

%% Résolution de l'équation du premier degré a+bx=c Syntaxe a b c resequ@

/resequ@{3 2 roll sub exch div} def


%% Placement d'un exposant
/depsup {0 talph@ c@h div 3 div rmoveto  /talph@  talph@ 0.8 mul store alph@ findfont talph@ scalefont setfont} def 
/retsup{/talph@ talph@ 1.25 mul store alph@ findfont talph@ scalefont setfont  0 talph@ c@h div 3 div neg rmoveto } def

%% Placement d'un indice inférieur
/depinf {0 talph@ c@h div 3 div neg rmoveto  /talph@  talph@ 0.8 mul store alph@ findfont talph@ scalefont setfont} def 
/retinf{/talph@ talph@ 1.25 mul store alph@ findfont talph@ scalefont setfont  0 talph@ c@h div 3 div  rmoveto } def

%/showalg {(^) search {showalg pop depsup showalg  retsup} {(_) search {showalg pop depinf showalg retinf}{show}ifelse} ifelse} %def

%% Choix du style de trait (tirete, plein, pointillé)
/traitplein {[] 0 setdash} def
/traittirete {[4] 0 setdash} def
/traitpointille {[2] 0 setdash} def

/droitehori {decoupler pop ordonnee dup x@i exch accoupler exch x@a exch accoupler accoupler segment} def
/droiteverti {decoupler pop abscisse dup y@i accoupler exch y@a  accoupler accoupler segment} def

/droite {/dr@ite exch store
             dr@ite decoupler abscisse exch abscisse eq 
            {dr@ite droiteverti} 
            {dr@ite decoupler ordonnee exch ordonnee eq
                          {dr@ite droitehori} 
	         {dr@ite droiteintercadre {segment} if} ifelse}
             ifelse} def
                   
/droiteintercadre {/dr@ite exch store  /d@f dr@ite decoupler exch subp store      
 	            dr@ite decoupler pop abscisse d@f abscisse    
                              2 copy  x@i resequ@ /t@1 exch store x@a resequ@ /t@2 exch store %t@1 bord gauche, t@2 bord droit
                              dr@ite decoupler pop ordonnee d@f ordonnee 
                              2 copy  y@i resequ@ /t@3 exch store y@a resequ@ /t@4 exch store  %t@3 bord inf t@4 bord sup
                          t@1 t@2 gt {/t@1 t@2 /t@2 t@1 store store} if
                          t@1 t@3 gt {/t@1 t@3 /t@3 t@1 store store} if
                          t@1 t@4 gt {/t@1 t@4 /t@4 t@1 store store} if                          
                          t@1 t@3 gt {/t@1 t@3 /t@3 t@1 store store} if
                          t@2 t@3 gt {/t@2 t@3 /t@3 t@2 store store} if
                          t@2 t@4 gt {/t@2 t@4 /t@4 t@2 store store} if
                          t@3 t@4 gt {/t@3 t@4 /t@4 t@3 store store} if
                          dr@ite decoupler pop d@f t@2 mulp addp 
                          dr@ite decoupler pop d@f t@3 mulp addp
                          2 copy dansdomaine? {dansdomaine? {accoupler true} {pop pop false} ifelse}
                          {pop pop pop false} ifelse
                           }def % OK



/demidroite {dup  decoupler /interm@ exch store /@ri exch store droiteintercadre 
                             {dup 0 get @ri accoupler interm@ exch danssegment?  
                              {0 get } {1 get} ifelse @ri accoupler segment} if} def 

/demidroitebis {dup  decoupler /interm@ exch store /@ri exch store droiteintercadre 
                             {dup 0 get @ri accoupler interm@ exch danssegment?  
                              {0 get } {1 get} ifelse @ri } if} def 
                        
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%  Decoupage du cadre en deux  régions déterminées par une droite %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/calculc@t {droiteintercadre  %c@t1 et c@t2: n° des cotés contenant b@p1 et b@p2
                             {decoupler /b@p2 exch store /b@p1 exch store 
                              b@p1 abscisse b@p2 abscisse gt   {/b@p1 b@p2  /b@p2 b@p1 store store} if       %b@p1 est le plus à gauche
                              b@p1 decoupler  dup y@i eq {pop pop /c@t1 1 store}   
                                                                             {y@a eq {pop /c@t1 3 store} {pop /c@t1 2 store} ifelse} ifelse 
                              b@p2 decoupler  dup y@i eq {pop pop /c@t2 1 store}           
                                                                             {y@a eq {pop /c@t2 3 store} {pop /c@t2 4 store} ifelse} ifelse} if } def

/coingicadre {calculc@t 
                        c@t1 1 eq {[ b@p1   [x@i y@i]  [x@i y@a]  c@t2 4 eq {[x@a y@a]} if b@p2 ] } if
                        c@t1 2 eq {[ [x@i y@i] b@p1  b@p2  c@t2 3 eq {[x@a y@a] [x@a y@i]} if c@t2 4 eq {[x@a y@i]} if ] } if
                        c@t1 3 eq {[ [x@i y@i] [x@i y@a] b@p1 b@p2 c@t2 4 eq {[x@a y@i]} if ]} if
                        } def

/coindscadre {calculc@t 
                        c@t1 1 eq  {[ b@p1 b@p2  c@t2 3 eq {[x@a y@a]} if [x@a y@i] ] } if 
                        c@t1 2 eq {[ b@p2 b@p1 [x@i y@a]  c@t2 1 eq {[x@a y@a] [x@a y@i]} if  c@t2 4 eq { [x@a y@a]} if ] } if
                        c@t1 3 eq {[ b@p1 b@p2  c@t2 1 eq {[x@a y@i] [x@a y@a]} if  c@t2 4 eq { [x@a y@a]} if  ]} if
                        } def


/interdroites {2 copy  vecnorperp exch vecnorparall scalp abs epszero lt
                   {pop pop false} 
                   {dup vecnorperp  dup 3 index decoupler  exch subp scalp 
                    3 1 roll exch decoupler  pop 3 index decoupler pop subp scalp
                    exch div dup /t@ exch store pointsurdroitegraduee true} ifelse} def
          % Syntaxe [p1 p2] [p3 p4] interdroites --> false ou pt true

/droiteintersegment {exch interdroites 
                         {t@ [0 1] dans? {true}{pop false} ifelse } 
                         {false} ifelse}def

          % Syntaxe [p1 p2] [p3 p4] droiteintersegment --> false ou pt true

/intersegments {2 copy droiteintersegment 
                   {pop exch droiteintersegment}
                   {pop pop false}          
                   ifelse} def

          % Syntaxe [p1 p2] [p3 p4] intersegments --> false ou pt true

/perpd {vecnorperp 1 index addp accoupler} def % syntaxe p1 [p2 p3] perpd
    % OK

/droiteperp{perpd droite} def
    % OK

/inclid {decoupler exch subp exch rota exch dup 3 1 roll addp accoupler} def
    % syntaxe p1 angle [p2 p3] inclid

/droiteincli {inclid droite} def

/vecnorperp {decoupler subp decoupler neg exch accoupler normer} def 
    %syntaxe [p1 p2] vecnorperp fournit une vecteur normé perpendiculaire à la droite [p1 p2] OK

/projection {dup 3 1 roll vecnorperp 1 index addp accoupler interdroites pop} def 
    %syntaxe p1 [p2 p3] projection --> proj

/paralld {decoupler exch subp 1 index addp accoupler} def %syntaxe p1 [p2 p3] paralld
    % OK
/droiteparall{paralld droite} def
    % OK
/droitemediatrice {mediatrid droite} def
    % OK
/mediatrid {dup  milieu exch perpd } def
    %OK
/droitebissectrice {bissecd droite} def
    %syntaxe [a b c] bissectrice %OK

/bissecd {decoupler 1 index subp normer 1 index addp 3 1 roll exch 1 index subp normer addp accoupler mediatrid} def             
    % OK


/vecnorparall{decoupler subp normer} def 
    %syntaxe [a b] vecnorparall fournit un vecteur normé parallèle à [a b] OK


/equerre {aload pop /r@y exch store  aload pop exch /c@ntre exch store
          c@ntre subp normer r@y mulp exch c@ntre subp normer r@y mulp 2 copy addp exch
          3 array astore [ exch {c@ntre addp} forall ] suitesegments} def

%%% Courbes

%% Calcul et/ou Dessin de l'image d'un point ou d'une courbe par une machine (transformation)

%Syntaxe /pointmobile t1 step t2 calculcourbe

/pointmobilelieu{dup gene1 exch gene2 interdroites } def

/pointmobileparam{dup fx exch fy accoupler true} def

/pointmobilepolaire{dup fr exch rad accoupler polverscar true} def

/pointmobilediff{dr@pp 0 eq {pop pt0 dup /pt@ exch store /dr@pp 1 store}
     {/t@ exch store pt@ t@ fx pt@ t@ fy accoupler ss mulp /k@1 exch store
      pt@ k@1 2 divp addp t@ ss 2 div add 2 copy fx 3 1 roll fy accoupler ss mulp /k@2 exch store
      pt@ k@2 2 divp addp t@ ss 2 div add 2 copy fx 3 1 roll fy accoupler ss mulp /k@3 exch store
      pt@ k@3 addp t@ ss add 2 copy fx 3 1 roll fy accoupler ss mulp /k@4 exch store
      k@1 k@2 2 mulp addp k@3 2 mulp addp k@4 addp 6 divp
      pt@ addp dup /pt@ exch store} ifelse true} def

/pointmobilefonction{dup f accoupler true} def

/calculcourbe {/dr@p 0 store 1 index /ss exch store /dr@pp 0 store
    4 -1 roll /p@tm@bile exch store 
    [ [ 5 2 roll  {p@tm@bile cvx exec
       {dr@p 1 eq {/t@mp exch store dup t@mp subp norme epsmax gt {][ t@mp }{t@mp}ifelse}
                         {/dr@p 1 store} 
                         ifelse}  
       {dr@p 1 eq {][/dr@p 0 store} if}  ifelse}  for 
       dr@p 1 eq {]}{pop} ifelse ] dup length 1 eq {decoupler} if} def  

/droiteintercourbe {exch /dr@ite exch store
                 nonemptyarray? 
                {dup 0 get point? exch pop 
                     {/c@urbe exch store c@urbe length /n@ exch store n@ 1 gt
                      {[ 0 1 n@ 2 sub {dup c@urbe exch get exch 1 add c@urbe exch get accoupler 
                                    dr@ite exch droiteintersegment pop}for ]}if }
                     {[ exch {dr@ite exch droiteintercourbe} forall ]} ifelse}
                {pop} ifelse} def %OK

%% syntaxe [a b] [[p1 p2....][p'1 p'2 ...] ....] droiteintercourbe

%% Moyenne géométrique de deux longueurs |o a| et |o b|, données par les deux points a et b

/moygeo {norme exch norme mul sqrt} def


/dessincourbe {calculcourbe suitesegments} def

/conique5p{[/a@ /b@ /c@ /d@ /e@] exch affectervaleurs
/T@ [d@ e@] store /U@ [b@ c@] store  /V@ [c@ d@] store conique} def

/conique4p1t{[/a@ /b@ /c@ /d@  /T@] exch affectervaleurs
/e@ d@ store  /U@ [b@ c@] store  /V@ [c@ d@] store conique} def

/conique3p2t{[/a@ /b@ /d@  /U@ /T@ ] exch affectervaleurs
/c@ b@ store /e@ d@ store  /V@ [c@ d@] store  conique} def

/hyperbolec2d{[/c@ /b@ /a@] exch affectervaleurs [b@ [c@  a@ b@ addp c@ subp][c@ b@ c@ addp a@ subp]]
                   hyperbole1p2a} def

/hyperbole3p1a{[/a@ /b@ /c@  /A@ ] exch affectervaleurs
[a@ b@] A@  interdroites pop /u@ exch store 
/gene1{a@ exch [a@ dup [1 0] addp] inclid dup /gen exch store} def
/gene2{pop gen c@ A@ paralld  interdroites {/w@ exch store /dr@2 1 store} {/dr@2 0 store} ifelse
dr@2 1 eq {/D@ [u@ w@] store} {/D@ A@ store} ifelse
[b@ c@] D@ interdroites {A@ paralld} {A@} ifelse} def
/pointmobilelieu 0 1 180 calculcourbe} def

/parabole3pda{[/a@ /b@ /c@  /A@] exch affectervaleurs
/gene1{a@ exch [a@ dup [1 0] addp] inclid dup /gen exch store} def
/gene2{pop gen c@ A@ paralld interdroites {/w@ exch store /dr@2 1 store} {/dr@2 0 store} ifelse
dr@2 1 eq  {/D@ w@ [a@ b@] paralld store} {/D@ [b@ c@] store} ifelse
[b@ c@] D@ interdroites {A@ paralld}{gen}ifelse} def
/pointmobilelieu 0 1 180 calculcourbe} def


/parabole4pter{a@ s@ subp dup b@ s@ subp moygeo 
                             exch normer exch mulp 
                            c@ s@ subp dup d@ s@ subp moygeo 
                             exch normer exch mulp 
                             2 copy addp origine accoupler /A@ exch store [a@ b@ c@ A@] parabole3pda
                             subp origine accoupler /A@ exch store [a@ b@ c@ A@] parabole3pda} def
/parabole4pb {[/a@ /b@ /c@  /d@] exch affectervaleurs
dr@1 2 lt {[a@ b@] [c@ d@] interdroites {/s@ exch store parabole4pter}
                                                                            {/dr@1 dr@1 1 add store [a@ c@ b@ d@] parabole4pb} 
                                                                            ifelse} if} def
/parabole4p{ /dr@1 0 store parabole4pb} def

/hyperbole1p2a{[/a@ /B@ /A@ ] exch affectervaleurs
A@ B@ interdroites {pop 
 a@ B@ paralld  A@  interdroites pop /u@ exch store 
/gene1{a@ exch [a@ dup [1 0] addp] inclid dup /gen exch store } def
/gene2{pop  u@ gen paralld  B@ interdroites {A@ paralld} {gen} ifelse } def
/pointmobilelieu 0 1 180 calculcourbe } if} def

/conique {[a@ b@] T@  interdroites {/u@ exch store /dr@1 1 store } {/dr@1 0 store } ifelse
                  /gene1{a@ exch [a@ dup [1 0] addp] inclid dup /gen exch store} def
                  /gene2{pop gen V@ interdroites {/w@ exch store /dr@2 1 store } {/dr@2 0 store } ifelse
                  dr@1 1 eq dr@2 1 eq and {/D@ [u@ w@] store} if
                  dr@1 0 eq dr@2 1 eq and {/D@ w@ T@ paralld store } if
                  dr@1 1 eq dr@2 0 eq and {/D@ u@ V@ paralld store} if
                  dr@1 0 eq dr@2 0 eq and {e@ U@ paralld} {U@ D@ interdroites {e@ accoupler}{e@ [b@ c@] paralld}ifelse}  ifelse} def
                  /pointmobilelieu 0 1 180 calculcourbe} def

/batonnets {dup nonemptyarray? 
                {0 get point? exch pop {{dup point dup abscisse 0 accoupler accoupler segment} forall}
                                 {{batonnets} forall} ifelse}
                {pop} ifelse} def %OK

/barres {/l@r exch store dup nonemptyarray? 
                {0 get point? exch pop {{dup abscisse 0 accoupler accoupler l@r accoupler 
                                         rectanglemedrempli} forall}
                                 {{l@r barres} forall} ifelse}
                {pop} ifelse} def %OK

/barresmultiples {/l@r exch store /c@uleurs exch store c@uleurs length /n@ exch store
                  {decoupler /s@m exch store /c@ exch store  
                   0 1 n@ 1 sub {/k@ exch store l@r k@ mul c@ add dup s@m k@ get accoupler 
                                 exch 0 accoupler accoupler l@r accoupler 
                                 c@uleurs k@ get fixecouleurfond rectanglemedrempli} for} forall
                  } def %OK

/histogramme {/ord@ exch store dup length /n@ exch store /l@rg exch store /deb@ exch store 
              0 1 n@ 1 sub {/k@ exch store [deb@ 0] deb@ l@rg k@ get add dup /deb@ exch store 
                            ord@ k@ get accoupler accoupler rectanglediag } for } def

/histogrammerempli {/ord@ exch store dup length /n@ exch store /l@rg exch store /deb@ exch store 
              0 1 n@ 1 sub {/k@ exch store [deb@ 0] deb@ l@rg k@ get add dup /deb@ exch store 
                            ord@ k@ get accoupler accoupler rectanglediagrempli } for } def

/escalier {/ord@ exch store dup length /n@ exch store /l@rg exch store /deb@ exch store 
              0 1 n@ 1 sub {/k@ exch store [deb@ ord@ k@ get] [deb@ l@rg k@ get add dup /deb@ exch store 
                            ord@ k@ get] accoupler segment} for } def

%%%%%%%%%%%%%%%% Etiquettes obliques ou courbes %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/etiqcourbe {dup length 1 eq{decoupler} if /@mpla exch store  /et@q exch store
                        et@q length 1 sub /l@ng exch store
                        0 1 l@ng   {/n@m exch store @mpla  n@m get dup 
                            n@m @mpla length 1 sub eq {@mpla 0 get}{@mpla  n@m 1 add get} ifelse
                           exch subp anglepolaire
                            gsave exch decoupler translate rotate
                            et@q n@m 1 getinterval origine etiqhord grestore} for  } def
/etiqsymbcourbe {dup length 1 eq{decoupler} if /@mpla exch store  /et@q exch store
                        et@q length 1 sub /l@ng exch store
                        0 1 l@ng   {/n@m exch store @mpla  n@m get dup 
                            n@m @mpla length 1 sub eq {@mpla 0 get}{@mpla  n@m 1 add get} ifelse
                           exch subp anglepolaire
                            gsave exch decoupler translate rotate
                            et@q n@m 1 getinterval origine etiqsymbhord grestore} for  } def


%% Routines "tortue"

/fixecaptortue{/captortue exch store}def
/fixepositortue{dup crayon 1 eq {positortue exch accoupler segment}{pop} ifelse
                /positortue exch store}def
/ga{captortue add /captortue exch store}def
/dr{neg ga }def
/av{[captortue dup cos exch sin] exch mulp positortue addp fixepositortue}def
/re{neg av}def
/lc{/crayon 0 store}def 
/bc{/crayon 1 store}def
/vers{positortue subp anglepolaire} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Valeurs par défaut %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/epsmax 1 store
/crayon 1 store
/captortue 90 store
/positortue [0 0] store

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Procédures globales %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/dessiner {/dr@pdessin true store /N 0 store {1 index N get exch cvx exec /N N 1 add store} forall pop  /r@pp 1 store /@nglerot 0 store baisserdr@p } def
/baisserdr@p {/dr@prot false store  /dr@phom false store /dr@paffi false store /dr@pdessin false store /dr@psym false store} def
/suitedessins {/dr@pdessin true store {instructions dessiner} forall baisserdr@p} def
%%% Transformations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Rotations syntaxe: suitepoints angle centre rotation
%%% Translations: suitepoints vecteur translation 

%%Un objet rotation est un triplet [angle centre /rotation]
%%Un groupe de rotations engendré par une rotation est un triplet [angle centre /groupederotations]
 

/r@t1{nombre? not {point? {c@ntr subp @ngrot rota c@ntr addp} {array? {[ exch  {r@t1} forall]} if} ifelse} if} def
/rotation{/dr@prot true store /c@ntr exch store /@ngrot exch store r@t1 /@ngrot 0 store } def

/groupederotations{/c@ntr exch store  /@ngrot exch store 
                [exch 360 dup @ngrot pgcd idiv  1 sub {dup r@t1} repeat ]
                } def 
/appliquer {aload pop cvx exec} def
%% syntaxe "suitepoints transfo appliquer" ou "suitepoints groupe appliquer"

%%%%%%%%% Rosaces    %Syntaxe :  Motif n centre Rn  Motif n centre droite Rnm
/ros@ce { [ exch it@r 1 sub {dup @ng c@ntr rotation} repeat ] typ@ (Rnm) eq {[ exch {decoupler} forall]} if } def
/fixerosace{ /typ@ exch store  /c@ntr exch store /it@r exch store /@ng 360 it@r div store typ@ (Rnm) eq {/dr@ite exch store} if } def
/Rn {/typ@ (Rn) store ros@ce} def
/Rnm {/typ@ (Rnm) store dup sym@ accoupler ros@ce} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Un objet translation est un couple [vecteur /translation]
%% Un groupe de translations est un couple [vecteur /groupedetranslations]

/tr@ns1 {nombre? not {point? {v@ct addp} {array? {[ exch {tr@ns1} forall ] } if}  ifelse }  if} def
/translation {/v@ct exch store tr@ns1} def
/demi@rbite {  {dup tr@ns1 dup dansdomaine? not {pop exit} if } loop } def
/groupedetranslations{/v@ct exch store /m@tif exch store [ m@tif demi@rbite /v@ct v@ct -1 mulp store 
 m@tif demi@rbite  ]} def
/dansdomaine? {nombre? {pop false} { point? {dup abscisse [x@i x@a] dans? exch ordonnee [y@i y@a] dans? and}
                                                              { array? {false exch {dansdomaine? or} forall }{pop false} ifelse } ifelse} ifelse  } def 
         %% syntaxe xx dansdomaine? ---> true ou false
         %% une suite de points est dans le domaine dès qu'un point de la suite est dans le domaine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/fr@se {v@ct groupedetranslations typ@ (F1) ne { [ exch {decoupler} forall ]} if } def
/fixefrise{/typ@ exch store 
                typ@ (F1) eq {/v@ct exch store} if
                typ@ (F2) eq {/c@ntr exch store /v@ct exch store /@ngrot 180 store} if
                typ@ (F1m) eq {/dr@ite exch store /v@ct exch store} if
                typ@ (Fm1) eq {/dr@ite exch store /v@ct exch store} if
                typ@ (F1g) eq {/dr@ite exch store /v@ct exch store /v@ct1 exch store} if
                typ@ (F2m) eq {/dr@1 exch store /dr@2 exch store /v@ct exch store} if
                typ@ (Fm2) eq {/dr@ite exch store /c@ntr exch store /v@ct exch store /@ngrot 180 store} if
               } def
/F1 {/typ@ (F1) store fr@se } def
/F2 {/typ@ (F2) store dup r@t1 accoupler fr@se} def
/F1m {/typ@ (F1m) store dup sym@ accoupler fr@se} def
/Fm1 {/typ@ (Fm1) store dup sym@ accoupler fr@se} def
/F1g {/typ@ (F1g) store dup tr@ns1 sym@ accoupler /v@ct v@ct1 store fr@se} def
/F2m {/typ@ (F2m) store dup dr@1 symetrie accoupler  dup dr@2 symetrie append fr@se} def
/Fm2 {/typ@ (Fm2) store dup sym@ accoupler dup  r@t1 append fr@se} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/c@mpos1 {decoupler exch v@ct2 ordonnee mul exch v@ct2 abscisse mul sub d@n div} def  
/c@mpos2 {decoupler v@ct1 abscisse mul exch v@ct1 ordonnee mul sub d@n div  } def  

/m@illage{v@ct1 abscisse v@ct2 ordonnee mul v@ct2 abscisse v@ct1 ordonnee mul sub /d@n exch store
                  /n@10 [x@i y@i] c@mpos1 store /n@1 n@10 store
                  [x@i y@a] c@mpos1 dup n@10 min /n@10 exch store n@1 max /n@1 exch store
                  [x@a y@i] c@mpos1 dup n@10 min /n@10 exch store n@1 max /n@1 exch store
                  [x@a y@a] c@mpos1 dup n@10 min /n@10 exch store n@1 max /n@1 exch store
                  /n@20 [x@i y@i] c@mpos2 store /n@2 n@20 store                  
                  [x@a y@i] c@mpos2 dup n@20 min /n@20 exch store n@2 max /n@2 exch store
                  [x@i y@a] c@mpos2 dup n@20 min /n@20 exch store n@2 max /n@2 exch store
                  [x@a y@a] c@mpos2 dup n@20 min /n@20 exch store n@2 max /n@2 exch store
                  /n@20 n@20 floor 1 sub store /n@10 n@10 floor 1 sub store
                  /n@1 n@1 ceiling 1 add store /n@2 n@2 1 add ceiling store} def

/@tom1 {nombre? {pop} {point? not {  {@tom1} forall  } if }  ifelse }  def
/@tomiser {[ exch {@tom1} forall ]} def 

/initi@lisation {m@tif  @tomiser  /m@t@tomise exch store m@t@tomise 0 get dup c@mpos1 /m@1 exch store 
c@mpos2 /m@2 exch store  1 1 m@t@tomise length 1 sub 
{m@t@tomise exch get dup c@mpos1 m@1 min /m@1 exch store c@mpos2 m@2 min /m@2 exch store} for 
                         /m@1 m@1 ceiling 1 add store /m@2 m@2 ceiling  1 add store} def

/p@vage{/m@tif exch store m@illage  initi@lisation  
                     [n@10 m@1 sub 1  n@1  {/i exch store  n@20 m@2 sub 1 n@2   
                                                               {/j exch store m@tif v@ct1 i mulp  v@ct2 j mulp addp translation} for
                                                                } for  ] typ@ (P1) ne { [ exch {decoupler} forall ]} if} def 

/fixemaille {/typ@ exch store /p@int exch store /v@ct1 exch store 
                 typ@ dup (P1) eq exch (P2) eq or { /v@ct2 exch store} if
                 typ@ dup dup dup dup (P3) eq exch (P6) eq or exch (Pm3) eq or exch (P3m) eq or exch (P6m) eq or{ /v@ct2 v@ct1 60 origine rotation  store} if
                 typ@ dup dup  (P4) eq exch (Pm4) eq or exch (P4m) eq or { /v@ct2 v@ct1 90 origine rotation  store} if                  
                 typ@ dup (Pm1) eq exch (Pm2) eq or {/v@ct2 v@ct1 origine p@int paralld symetrie store /p@int p@int 0 get store} if
                 typ@ dup dup dup (P1m) eq exch (P2m) eq or exch (P1g) eq or exch (Pg2) eq or
                        {/l@n v@ct1 store /v@ct1 p@int decoupler exch subp store /v@ct2 p@int vecnorperp l@n neg mulp store /p@int p@int 0 get store} if  
                  typ@ (P2g) eq {p@int v@ct1 symetrie p@int exch 180 exch rotation p@int subp /v@ct2 exch store /v@ct1 v@ct1 decoupler exch subp store} if

                  /m@ille [p@int dup v@ct1 addp dup v@ct2 addp dup v@ct1 subp]  store 
                  [/ms1 /ms2 /ms3 /ms4] m@ille affectervaleurs
                  /mc m@ille isobarycentre store  %centre de la maille
                  /mmc12   [ms1 ms2] milieu store /mmc23  [ms2 ms3]  milieu store  /mmc34  [ms3 ms4]  milieu store /mmc41  [ms4 ms1]  milieu store    %milieux des cotes
                   /mct1 [ms1 ms2 ms4] isobarycentre store /mct2 [ms2 ms3 ms4] isobarycentre store %centres des deux triangles
}  def 

%%% dessinmaille syntaxe:  v1 éventuellement v2 p (P**) dessinmaille %%%%%%%%%%%%%%%%%%%%%%%

/bordm@ille {[ms1 0.9 ms2] fleche [ms1 0.9 ms4] fleche sauvecouleurs noir fixecouleurtrait [ms2 ms3 ms4] suitesegments restaurecouleurs} def

/milieuxm@ille {  [mmc12 mmc23 mmc34 mmc41]  } def

/tiersm@ille {[ mct1 mct2 ]} def

/z@negrise {sauvecouleurs gris fixecouleurfond noir fixecouleurtrait polygonerempli restaurecouleurs} def

/dessinmaille {typ@ (P1) eq {m@ille z@negrise bordm@ille} if
                       typ@ (P2) eq {[ms1 mmc12 mmc34 ms4] z@negrise bordm@ille
                                              /pavelosange fixeformepoint m@ille suitepoints milieuxm@ille suitepoints mc point } if
                        typ@ (P3) eq {[mct1  ms2  mct2 ms4 ] z@negrise bordm@ille
                                              /pavetriangle fixeformepoint m@ille suitepoints tiersm@ille suitepoints  } if
                       typ@ (P4) eq { [ms1 mmc12 mc mmc41]  z@negrise bordm@ille
                                              /pavecarre fixeformepoint m@ille suitepoints mc point 
                                              /pavelosange fixeformepoint milieuxm@ille suitepoints  } if
                       typ@ (P6) eq { [ms1  ms2 mct1 ]  z@negrise bordm@ille
                                              /pavehexagone fixeformepoint m@ille suitepoints /pavetriangle fixeformepoint tiersm@ille suitepoints
                                              /pavelosange fixeformepoint milieuxm@ille suitepoints mc  point  } if
                       typ@ (Pm1) eq {[ms1 ms3 ms4] z@negrise bordm@ille [ms1 ms3] segment  } if
                       typ@ (P1m) eq {[ms1 ms2 mmc23 mmc41] z@negrise bordm@ille [mmc23 mmc41] segment  } if       
                       typ@ (Pm2) eq {[ms1 ms2 mc] z@negrise bordm@ille [ms1 ms3] segment  [ms2 ms4] segment 
                                                /pavelosange fixeformepoint m@ille suitepoints milieuxm@ille suitepoints mc point } if
                       typ@ (P2m) eq {[ms1 mmc12 mc mmc41] z@negrise bordm@ille [mmc23 mmc41] segment [mmc12 mmc34] segment
                                               [ms2 ms3 ms4] suitesegments /pavelosange fixeformepoint m@ille suitepoints milieuxm@ille suitepoints mc point} if
                        typ@ (P2g) eq {[ms1 [ms1 mmc41] milieu [ms2 mmc23] milieu ms2] z@negrise bordm@ille
                                                 [[[ms1 mmc41] milieu [ms2 mmc23] milieu] [[ms4 mmc41] milieu [ms3 mmc23] milieu]] suitesegments
                                                 /pavelosange fixeformepoint m@ille suitepoints mc point milieuxm@ille suitepoints} if
                        typ@ (Pm3) eq {[mct1  ms2  ms4 ] z@negrise bordm@ille [ms2 ms4] segment
                                              /pavetriangle fixeformepoint m@ille polygonepointe tiersm@ille suitepoints } if
                        typ@ (P3m) eq {[mct1  mct2 ms2 ] z@negrise bordm@ille [ms1 ms3] segment [mmc23 ms4 mmc12] suitesegments 
                                              [mmc41 ms2 mmc34] suitesegments
                                              /pavetriangle fixeformepoint m@ille polygonepointe tiersm@ille suitepoints } if
                       typ@ (Pm4) eq { [ms1 mmc12 mmc41]  z@negrise bordm@ille
                                                  [mmc12 mmc23 mmc34 mmc41] polygone
                                              /pavecarre fixeformepoint m@ille suitepoints mc point 
                                              /pavelosange fixeformepoint milieuxm@ille suitepoints } if
                        typ@ (P4m) eq { [ms1 mmc12 mc]  z@negrise bordm@ille
                                                  [[mmc12 mmc34] [mmc23 mmc41] [ms1 ms3] [ms2 ms4]] suitesegments
                                              /pavecarre fixeformepoint m@ille polygonepointe mc point 
                                              /pavelosange fixeformepoint milieuxm@ille suitepoints } if
                        typ@ (P6m) eq {[ms1  mmc12 mct1] z@negrise bordm@ille [[ms1 ms3] [ms2 ms4]] suitesegments
                                                 [mmc23 ms4 mmc12] suitesegments  [mmc41 ms2 mmc34] suitesegments
                                              /pavehexagone fixeformepoint m@ille polygonepointe 
                                              /pavetriangle fixeformepoint tiersm@ille suitepoints /pavelosange fixeformepoint milieuxm@ille suitepoints 
                                               mc point} if
                       typ@ (P1g) eq {[ms1 ms4 mmc34 mmc12] z@negrise bordm@ille traittirete [mmc41 0.5 mc] fleche [ms4 0.5 mmc34] fleche} if     
                       typ@ (Pg2) eq {[ms1 mmc12 mc mmc41] z@negrise bordm@ille traittirete 
                                                  [[ms1 mmc41] milieu 0.5 [mmc12 mc] milieu] fleche [[ms4 mmc41] milieu 0.5 [mmc34 mc] milieu] fleche
                                                  [[ms1 mmc12] milieu 0.5 [mmc41 mc] milieu] fleche [[ms2 mmc12] milieu 0.5 [mmc23 mc] milieu] fleche
                                                  traitplein /pavelosange fixeformepoint m@ille suitepoints milieuxm@ille suitepoints mc point } if    
} def

/P1 {/typ@ (P1) store p@vage} def

/P2 {/typ@ (P2) store dup 180 ms1 rotation accoupler p@vage} def

/P3 {/typ@ (P3) store 2 {dup 120 ms1 rotation} repeat  3 array astore  p@vage } def

/P4 {/typ@ (P4) store 3 {dup 90 ms1 rotation} repeat   4 array astore  p@vage} def

/P6 {/typ@ (P6) store 5 {dup 60 ms1 rotation} repeat  6 array astore  p@vage } def

/Pm1 {/typ@ (Pm1) store dup  [ms1 ms3] symetrie accoupler p@vage}def

/P1m {/typ@ (P1m) store dup [mmc41 mmc23] symetrie accoupler p@vage}def

/P1g {/typ@ (P1g) store dup mc mmc41 subp translation [mmc41 mc] symetrie accoupler p@vage}  def

/Pm2 {/typ@ (Pm2) store dup [ms1 ms3] symetrie  accoupler dup [ms2 ms4] symetrie append  p@vage } def

/P2m {/typ@ (P2m) store dup [mmc12 mmc34] symetrie  accoupler dup [mmc41 mmc23] symetrie append p@vage} def

/P2g {/typ@ (P2g) store dup [[ms1 mmc41] milieu [ms2 mmc23] milieu] symetrie accoupler dup 180 mc rotation append p@vage} def

/Pg2 {/typ@ (Pg2) store dup mmc12 ms1 subp translation [[ms1 mmc41] milieu  [mmc12 mc] milieu] symetrie accoupler  dup 180 mc rotation append p@vage} def

/Pm3 {/typ@ (Pm3) store 2 {dup 120 mct1 rotation} repeat  3 array astore dup [ms2 ms4] symetrie append  p@vage} def

/P3m {/typ@ (P3m) store 2 {dup 120 mct1 rotation} repeat  3 array astore  dup [ms1 ms3] symetrie  append  p@vage } def

/Pm4 {/typ@ (Pm4) store dup [mmc12 mmc41] symetrie accoupler dup 90  mc rotation append dup 180 mc rotation append p@vage } def 

/P4m {/typ@ (P4m) store dup [mmc12 mmc34] symetrie accoupler dup 90  mc rotation append dup 180 mc rotation append p@vage } def 

/P6m {/typ@ (P6m) store dup [ms1 ms3] symetrie accoupler  dup 2 {120 mct1 rotation dup} repeat pop append append dup [ms2 ms4] symetrie append p@vage} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Un objet homothetie est un triplet [rapport centre  /homothetie]
%% Un groupe d'homotheties est un triplet [rapport centre  /orbitehomothetie]

/h@m1{point? {c@ntr subp r@pp mulp c@ntr addp}
                        {array? {cercle? {decoupler r@pp mul exch h@m1 exch accoupler} {[exch {h@m1} forall] }  ifelse}  if } 
                        ifelse } def
/homothetie{/dr@phom true store /c@ntr exch store /r@pp exch store h@m1} def


/grouped'homotheties{/c@ntr exch store /r@pp exch store /r@ppn r@pp abs store
               [ exch  { dup h@m1 /r@ppn r@ppn r@pp abs mul store dup dansdomaine? not r@ppn abs 0.001 le or {exit} if} loop 
                /r@pp 1 r@pp div store /r@ppn r@pp abs  store  { dup h@m1 /r@ppn r@ppn  r@pp abs mul store dup dansdomaine? not r@ppn 0.001 le or {exit} if} loop]
               } def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Un objet similitude est un quadruplet [rapport angle centre  /similitude]
%% Un groupe de similitudes est un triplet [rapport angle centre  /orbitesimilitude]

/s@m1{point? { c@ntr subp r@pp mulp  @ng rota c@ntr addp }
                       {array? {cercle? {decoupler r@pp mul exch s@m1 exch accoupler} {[exch {s@m1} forall]} ifelse} if }
                       ifelse } def
/similitude{/dr@phom true store /dr@prot true store /c@ntr exch store /@ng exch store /r@pp exch store s@m1} def

/groupedesimilitudes{/c@ntr exch store /@ng exch store /r@pp exch store  /r@ppn r@pp abs store
               [ exch  { dup s@m1 /r@ppn r@ppn r@pp abs mul store dup dansdomaine? not  r@ppn abs 0.001 le or {exit} if} loop 
                /r@pp 1 r@pp div store /r@ppn r@pp abs  store /@ng @ng neg store  
               { dup s@m1 /r@ppn r@ppn  r@pp abs mul store dup dansdomaine? not  r@ppn 0.001 le or {exit} if} loop]
               } def
%% Calcul de la matrice de la  similitude appliquant [s1@ s2@] sur [b1@ b2@]
%% Syntaxe s1@ s2@ b1@ b2@ sim4p --> M On applique ensuite la similitude par "[matrice affinite] appliquer"
/sim4p {10 dict begin /b2@ exch def /b1@ exch def /s2@ exch def /s1@ exch def
                                    /w@  s2@ s1@ subp def  /q@ b2@ b1@ subp def
                                    /d@2 w@ norme dup mul def
                                    /M@ [ w@ d@2 divp decoupler w@ d@2 divp decoupler  neg  exch 0 0] def
                                    q@ decoupler neg  M@ transform accoupler /w1@ exch def
                                    q@ decoupler exch M@ transform accoupler /w2@ exch def
                                     [w1@ abscisse w2@ abscisse w1@ ordonnee w2@ ordonnee 
                                                  b1@ abscisse w1@ s1@ scalp sub b1@ ordonnee w2@ s1@ scalp sub ] end } def
%% Calcul des paramètres de la similitude. Toujours déposer d'abord la matrice sur la pile
/anglesim4p {decoupler pop pop pop pop exch atan} def
/rapportsim4p{ determ abs sqrt} def
/centresim4p{10 dict begin dup anglesim4p /alpha exch def dup rapportsim4p /k exch def 
                                            dup determ 2 k mul alpha cos mul sub 1 add /delta exch def
                                            delta abs epszero gt {
                                            decoupler /v3y exch def /v3x exch def pop pop pop pop
                                            /k1 1 k alpha cos mul sub def /k2 k alpha sin mul def
                                            [ v3x k1 mul v3y k2 mul sub delta div v3y k1 mul v3x k2 mul add delta div ] } if  end} def

%%%% Dessin d'un arc de spirale  [ secteur coeff rayon de départ] arcspirale 
/arcsp@ri {desassembler  /c@eff exch store /s@c exch store s@c 1 get /c@ntre exch store
              newpath s@c 0 get   /d@@b exch store 
              s@c 0 get c@ntre subp anglepolaire /@1 exch store
              s@c 2 get c@ntre subp anglepolaire /@2 exch store
              @ri 0 gt {@1 @2 gt {@2 360 add /@2 exch store} if}
                            {@1 @2 lt {@2 360 sub /@2 exch store} if} ifelse 
              s@c 2 get c@ntre subp norme s@c 0 get c@ntre subp norme  div  1 30 div exp /r@p exch store 
              @2 @1 sub  30 div  /@lpha exch store 
              [ d@@b 1 1 30 { pop d@@b  [r@p  @lpha c@ntre /similitude] appliquer  dup  /d@@b exch store} for ] 
               suitesegments  
              c@eff 0 ne {puttip} if
} def

/puttip {@2 @1 sub pi mul 180 div /@n exch store
              s@c 2 get c@ntre subp norme s@c 0 get c@ntre subp norme  div ln /logr@n exch store
              s@c 0 get  [c@eff 30 mul dup r@p exch exp exch @lpha mul c@ntre /similitude ] appliquer
              dup c@ntre subp anglepolaire exch decoupler moveto @n logr@n  atan add  tip
              } def


/arcsporipos {/@ri 1 store arcsp@ri} def
/arcsporineg {/@ri -1 store arcsp@ri} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Un objet symétrie axiale est un couple [droite  /symetrie]
/sym@{nombre? {} {point? {dup dr@ite perpd dr@ite interdroites pop 2 mulp exch subp}
                                                                    {array? {[exch {sym@} forall] } if } ifelse } ifelse } def
/symetrie{/dr@psym true store /dr@ite exch store  sym@ } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Un objet inversion est un couple [cercle  /inversion]
/inv@{nombre? {}
           {point? {c@rcle decoupler dup mul 3 1 roll exch accoupler dup distance dup mul exch 3 1 roll div pointsurdroitegraduee}
                       {[ exch {inv@} forall]}ifelse}ifelse } def
/inversion{/c@rcle exch store  inv@} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%Cercles orthogonaux 
%% a) Syntaxe: cercle point1 point2 cercleortho2p --> cercleortho
/cercleortho2p{/p@int2 exch store /p@int1 exch store /c@rcle exch store 
/c@ntre c@rcle 0 get store /r@ c@rcle 1 get store
c@ntre [p@int1 p@int2] alignes? {[p@int1 p@int2]}
{/a@ c@ntre 0 dup cos exch sin accoupler r@ mulp addp store
/b@ c@ntre 120 dup cos exch sin accoupler r@ mulp addp store
/c@ c@ntre 240 dup cos exch sin accoupler r@ mulp addp store
/c@rc2 [p@int1 [p@int1 p@int2] distance] store 
[a@ b@ c@] c@rc2 inversion cerc3p decoupler pop p@int2 exch accoupler /dr@ite exch store
dr@ite c@rc2 pointinter2drcerc 
[ exch p@int1 p@int2]  cerc3p} ifelse } def


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Un objet affinite est un couple [matrice /affinite]
/@ffi {point? {decoupler m@trice transform accoupler}
                     {array? {[exch {@ffi} forall]} if } ifelse} def
/affinite {/dr@paffi true store /m@trice exch store  @ffi} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Valeurs par  défaut.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

end
%%EndProlog
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/debut {
%%/P@r@mAjust where {pop /CoeffAjust P@r@mAjust dup 0 get exch 2 get div store}{/CoeffAjust 1 store} ifelse
/CoeffAjust 1 store
macrosgn begin /saveobj save store
/pilem@t [] store
usertrue
[[1 cm 1 cm ][11 cm 11 cm]] fixecadre
0 fixeposy
0 fixeposx
1 fixepasgraduationx
1 fixepasgraduationy
/l@belx false store
/l@bely false store
/orientationpointe 0 store
5 fixelongueurmarques
/dot fixeformepoint
/segmentdroit fixeformesegment
/rayoncoin 0 store
noir fixecouleurtrait
noir fixecouleurfond
noir fixecouleurtexte
0 fixemoderemplissage
/Symbol fixepolicesymbolique 
/Times-BoldItalic fixepolice 
12 fixecorps %OK
1.2 fixetaillepoint
1 fixeepaisseurtrait
/epszero 0.000003 store
/epsmax 1 store
/crayon 1 store
/captortue 90 store
/positortue [0 0] store
baisserdr@p
/@ng 0 store
} def

/fin {saveobj restore end} def
